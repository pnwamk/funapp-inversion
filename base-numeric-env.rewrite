#lang s-exp "env-lang.rkt"

(begin
  (require
   (for-syntax racket/base racket/syntax syntax/parse)
   (only-in (rep type-rep values-rep) Type? make-Values)
   racket/list racket/math racket/flonum racket/extflonum racket/unsafe/ops racket/sequence racket/match
   (for-template racket/flonum racket/extflonum racket/fixnum racket/math racket/unsafe/ops racket/base
                 (only-in "../types/numeric-predicates.rkt" index?))
   (only-in (types abbrev numeric-tower) [-Number N] [-Boolean B] [-Symbol Sym] [-Real R] [-PosInt -Pos]))
  ;; TODO having definitions only at the top is really inconvenient.

  (define all-int-types
    (list Zero One Positive-Byte Byte Positive-Index Index
          Positive-Fixnum Nonnegative-Fixnum Negative-Fixnum Nonpositive-Fixnum Fixnum
          Positive-Integer Nonnegative-Integer Negative-Integer Nonpositive-Integer Integer))
  (define rat-types (list Positive-Rational Nonnegative-Rational Negative-Rational Nonpositive-Rational Rational))

  (define all-rat-types (append all-int-types rat-types))
  (define all-flonum-types
    (list Float-Positive-Zero Float-Negative-Zero Float-Zero Float-NaN
          Positive-Float Nonnegative-Float Negative-Float Nonpositive-Float Float))
  (define single-flonum-types
    (list Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero Single-Flonum-NaN
          Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float Single-Float))
  (define inexact-real-types
    (list Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero Inexact-Real-NaN
          Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real))
  (define all-float-types (append all-flonum-types single-flonum-types inexact-real-types))
  (define real-types (list Real-Zero Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real Real))
  (define all-real-types (append all-rat-types all-float-types real-types))
  (define number-types
    (list Exact-Number Float-Complex Single-Float-Complex Inexact-Complex Number))
  (define all-number-types (append all-real-types number-types))


  ;; convenient to build large case-lambda types
  (define (from-cases . cases)
    (apply cl->* (flatten cases)))
  ;; for fixnum-specific operations. if they return at all, we know
  ;; their args were fixnums. otherwise, an error would have been thrown
  ;; for the moment, this is only useful if the result is used as a test
  ;; once we have a set of props that are true/false based on reaching
  ;; a certain point, this will be more useful
  (define (fx-from-cases . cases)
    (apply from-cases (map (lambda (x)
                             (add-unconditional-prop-all-args
                              x Fixnum))
                           (flatten cases))))

  (define (binop t [r t])
    (t t . -> . r))
  (define (varop t [r t])
    (->* (list) t r))
  (define (varop-1+ t [r t])
    (->* (list t) t r))

  (define (unop t) (-> t t))

  (define (commutative-binop a1 a2 [r a2])
    (list (-> a1 a2 r) (-> a2 a1 r)))
  ;; when having at least one of a given type matters (e.g. adding one+ Pos and Nats)
  (define (commutative-case t1 t2 [r t1])
    (list (->* (list t1 t2) t2 r)
          (->* (list t2 t1) t2 r)
          (->* (list t2 t2 t1) t2 r)))

  (define (comp t1 [t2 t1])
    (-> t1 t2 B))
  ;; simple case useful with equality predicates.
  ;; if the equality is true, we know that general arg is in fact of specific type.
  (define (commutative-equality/prop general specific)
    (list (-> general specific Boolean : (-PS (-is-type 0 specific) -tt))
          (-> specific general Boolean : (-PS (-is-type 1 specific) -tt))))

  ;; if in addition if the equality is false, we know that general arg is not of the specific type.
  (define (commutative-equality/strict-prop general specific)
    (list (-> general specific Boolean : (-PS (-is-type 0 specific) (-not-type 0 specific)))
          (-> specific general Boolean : (-PS (-is-type 1 specific) (-not-type 1 specific)))))


  (define round-type ; also used for truncate
    (lambda ()
      (from-cases
       (map unop all-int-types)
       (-> Nonnegative-Rational Nonnegative-Integer)
       (-> Nonpositive-Rational Nonpositive-Integer)
       (-> Rational Integer)
       (map unop (list Float-Positive-Zero Float-Negative-Zero Float-Zero
                       Nonnegative-Float Nonpositive-Float Float
                       Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero
                       Nonnegative-Single-Float Nonpositive-Single-Float Single-Float
                       Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero
                       Nonnegative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                       Real-Zero Nonnegative-Real Nonpositive-Real Real)))))
  
  (define (inexact-zero->exact-zero-type)
    (for/list ([t (in-list
                    (list Float-Positive-Zero Float-Negative-Zero Float-Zero
                          Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero
                          Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero
                          Real-Zero))])
      (-> t Zero)))
  
  (define (exact-round-type) ; also used for exact-truncate
    (from-cases
     (map unop all-int-types)
     (inexact-zero->exact-zero-type)
     (-> (union Nonnegative-Rational Nonnegative-Float Nonnegative-Single-Float Nonnegative-Inexact-Real Nonnegative-Real) Nonnegative-Integer)
     (-> (union Nonpositive-Rational Nonpositive-Float Nonpositive-Single-Float Nonpositive-Inexact-Real Nonpositive-Real) Nonpositive-Integer)
     (-> (union Rational Float Single-Float Inexact-Real Real) Integer)))
  
  (define fl-unop (lambda () (unop Float)))
  (define extfl-unop (lambda () (unop -ExtFlonum)))

  ;; types for specific operations, to avoid repetition between safe and unsafe versions
  (define fx+-type
    (lambda ()
      (fx-from-cases
       (-> Zero Integer Fixnum : -true-propset : (-arg-path 1))
       (-> Integer Zero Fixnum : -true-propset : (-arg-path 0))
       (commutative-binop Positive-Byte Byte Positive-Index)
       (binop Byte Index)
       ;; in other cases, either we stay within fixnum range, or we error
       (commutative-binop -Pos Nonnegative-Integer Positive-Fixnum)
       (Nonnegative-Integer Nonnegative-Integer . -> . Nonnegative-Fixnum)
       (commutative-binop Negative-Integer One Nonpositive-Fixnum)
       (commutative-binop Negative-Integer Nonpositive-Integer Negative-Fixnum)
       (Nonpositive-Integer Nonpositive-Integer . -> . Nonpositive-Fixnum)
       (Integer Integer . -> . Fixnum))))
  (define fx--type
    (lambda ()
      (fx-from-cases
       (-> Integer Zero Fixnum : -true-propset : (-arg-path 0))
       (One One . -> . Zero)
       (Positive-Byte One . -> . Byte)
       (Positive-Index One . -> . Index)
       (Positive-Integer One . -> . Nonnegative-Fixnum)
       (Negative-Integer Nonnegative-Integer . -> . Negative-Fixnum)
       (Nonpositive-Integer Positive-Integer . -> . Negative-Fixnum)
       (Nonpositive-Integer Nonnegative-Integer . -> . Nonpositive-Fixnum)
       (Positive-Integer Nonpositive-Integer . -> . Positive-Fixnum)
       (Nonnegative-Integer Negative-Integer . -> . Positive-Fixnum)
       (Nonnegative-Integer Nonpositive-Integer . -> . Nonnegative-Fixnum)
       (Integer Integer . -> . Fixnum))))
  (define fx*-type
    (lambda ()
      (fx-from-cases
       (-> One Integer Fixnum : -true-propset : (-arg-path 1))
       (-> Integer One Fixnum : -true-propset : (-arg-path 0))
       (commutative-binop Integer Zero)
       (Positive-Byte Positive-Byte . -> . Positive-Index)
       (Byte Byte . -> . Index)
       (Positive-Integer Positive-Integer . -> . Positive-Fixnum)
       (commutative-binop Positive-Integer Negative-Integer Negative-Fixnum)
       (Negative-Integer Negative-Integer . -> . Positive-Fixnum)
       (Nonnegative-Integer Nonnegative-Integer . -> . Nonnegative-Fixnum)
       (commutative-binop Nonnegative-Integer Nonpositive-Integer Nonpositive-Fixnum)
       (Nonpositive-Fixnum Nonpositive-Fixnum . -> . Nonnegative-Fixnum)
       (Integer Integer . -> . Fixnum))))
  (define fxquotient-type
    (lambda ()
      (fx-from-cases
       (Zero Integer . -> . Zero)
       (-> Integer One Fixnum : -true-propset : (-arg-path 0))
       (Byte Nonnegative-Integer . -> . Byte)
       (Index Nonnegative-Integer . -> . Index)
       (Nonnegative-Integer Nonnegative-Integer . -> . Nonnegative-Fixnum)
       (commutative-binop Nonnegative-Integer Nonpositive-Integer Nonpositive-Fixnum)
       (Nonpositive-Integer Nonpositive-Integer . -> . Nonnegative-Fixnum)
       (Integer Integer . -> . Fixnum))))
  (define fxremainder-type ; result has same sign as first arg
    (lambda ()
      (fx-from-cases
       (One One . -> . Zero)
       (map (lambda (t) (list (-> Nonnegative-Integer t t)
                              (-> t Integer t)))
            (list Byte Index))
       (Nonnegative-Integer Integer . -> . Nonnegative-Fixnum)
       (Nonpositive-Integer Integer . -> . Nonpositive-Fixnum)
       (Integer Integer . -> . Fixnum))))
  (define fxmodulo-type ; result has same sign as second arg
    (lambda ()
      (fx-from-cases
       (One One . -> . Zero)
       (map (lambda (t) (list (-> Integer t t)
                              (-> t Nonnegative-Integer t)))
            (list Byte Index))
       (Integer Nonnegative-Integer . -> . Nonnegative-Fixnum)
       (Integer Nonpositive-Integer . -> . Nonpositive-Fixnum)
       (Integer Integer . -> . Fixnum))))
  (define fxabs-type
    (lambda ()
      (fx-from-cases
       (-> Nonnegative-Integer Nonnegative-Fixnum : -true-propset : (-arg-path 0))
       ((union Positive-Integer Negative-Integer) . -> . Positive-Fixnum)
       (Integer . -> . Nonnegative-Fixnum))))
  (define fx=-type
    (lambda ()
      (fx-from-cases
       ;; we could rule out cases like (= Pos Neg), but we currently don't
       (commutative-equality/strict-prop Integer Zero)
       (map (lambda (t) (commutative-equality/prop Integer t))
            (list One Positive-Byte Byte Positive-Index Index Positive-Fixnum Nonnegative-Fixnum Negative-Fixnum Nonpositive-Fixnum))
       (comp Integer))))
  (define fx<-type
    (lambda ()
      (fx-from-cases
       (-> Integer One Boolean : (-PS (-is-type 0 Nonpositive-Fixnum) (-is-type 0 Positive-Fixnum)))
       (-> Integer Zero Boolean : (-PS (-is-type 0 Negative-Fixnum) (-is-type 0 Nonnegative-Fixnum)))
       (-> Zero Integer Boolean : (-PS (-is-type 1 Positive-Fixnum) (-is-type 1 Nonpositive-Fixnum)))

       (-> Byte Positive-Byte Boolean : (-PS -tt (-is-type 0 Positive-Byte)))
       (-> Byte Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt))
       (-> -Pos Byte Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
       (-> Byte -Pos Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
       (-> Byte Nonnegative-Integer Boolean : (-PS -tt (-is-type 1 Byte)))
       (-> Index Positive-Index Boolean : (-PS -tt (-is-type 0 Positive-Index)))
       (-> Index Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
       (-> -Pos Index Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
       (-> Index -Pos Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
       (-> Nonnegative-Integer Byte Boolean : (-PS (-and (-is-type 0 Byte) (-is-type 1 Positive-Byte)) -tt))
       (-> Nonnegative-Integer Index Boolean : (-PS (-and (-is-type 0 Index) (-is-type 1 Positive-Index)) -tt))
       (-> Index Nonnegative-Integer Boolean : (-PS -tt (-is-type 1 Index)))
       ;; general integer cases
       (-> Integer Positive-Integer Boolean : (-PS -tt (-is-type 0 Positive-Fixnum)))
       (-> Integer Nonnegative-Integer Boolean : (-PS -tt (-is-type 0 Nonnegative-Fixnum)))
       (-> Nonnegative-Integer Integer Boolean : (-PS (-is-type 1 Positive-Fixnum) -tt))
       (-> Integer Nonpositive-Integer Boolean : (-PS (-is-type 0 Negative-Fixnum) -tt))
       (-> Negative-Integer Integer Boolean : (-PS -tt (-is-type 1 Negative-Fixnum)))
       (-> Nonpositive-Integer Integer Boolean : (-PS -tt (-is-type 1 Nonpositive-Fixnum)))
       (comp Integer))))
  (define fx>-type
    (lambda ()
      (fx-from-cases
       (-> One Integer Boolean : (-PS (-is-type 1 Nonpositive-Fixnum) (-is-type 1 Positive-Fixnum)))
       (-> Zero Integer Boolean : (-PS (-is-type 1 Negative-Fixnum) (-is-type 1 Nonnegative-Fixnum)))
       (-> Integer Zero  Boolean : (-PS (-is-type 0 Positive-Fixnum) (-is-type 0 Nonpositive-Fixnum)))

       (-> Positive-Byte Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
       (-> Byte Byte Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
       (-> Byte -Pos Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
       (-> -Pos Byte Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
       (-> Byte Nonnegative-Integer Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Byte)) -tt))
       (-> Positive-Index Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
       (-> Index Index Boolean : (-PS (-is-type 0 Positive-Index) -tt))
       (-> Index -Pos Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
       (-> -Pos Index Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
       (-> Index Nonnegative-Integer Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Index)) -tt))
       (-> Nonnegative-Integer Byte Boolean : (-PS -tt (-is-type 0 Byte)))
       (-> Nonnegative-Integer Index Boolean : (-PS -tt (-is-type 0 Index)))
       ;; general integer cases
       (-> Positive-Integer Integer Boolean : (-PS -tt (-is-type 1 Positive-Fixnum)))
       (-> Nonnegative-Integer Integer Boolean : (-PS -tt (-is-type 1 Nonnegative-Fixnum)))
       (-> Integer Nonnegative-Integer Boolean : (-PS (-is-type 0 Positive-Fixnum) -tt))
       (-> Nonpositive-Integer Integer Boolean : (-PS (-is-type 1 Negative-Fixnum) -tt))
       (-> Integer Negative-Integer Boolean : (-PS -tt (-is-type 0 Negative-Fixnum)))
       (-> Integer Nonpositive-Integer Boolean : (-PS -tt (-is-type 0 Nonpositive-Fixnum)))
       (comp Integer))))
  (define fx<=-type
    (lambda ()
      (fx-from-cases
       (-> Integer One Boolean : (-PS (-is-type 0 (union Nonpositive-Fixnum One)) (-is-type 0 Positive-Fixnum)))
       (-> One Integer Boolean : (-PS (-is-type 1 Positive-Fixnum) (-is-type 1 Nonpositive-Fixnum)))
       (-> Integer Zero Boolean : (-PS (-is-type 0 Nonpositive-Fixnum) (-is-type 0 Positive-Fixnum)))
       (-> Zero Integer Boolean : (-PS (-is-type 1 Nonnegative-Fixnum) (-is-type 1 Negative-Fixnum)))

       (-> Positive-Byte Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt))
       (-> Byte Byte Boolean : (-PS -tt (-is-type 0 Positive-Byte)))
       (-> -Pos Byte Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
       (-> Byte -Pos Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
       (-> Byte Nonnegative-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Byte))))
       (-> Positive-Index Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
       (-> Index Index Boolean : (-PS -tt (-is-type 0 Positive-Index)))
       (-> -Pos Index Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
       (-> Index -Pos Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
       (-> Nonnegative-Integer Byte Boolean : (-PS (-is-type 0 Byte) -tt))
       (-> Nonnegative-Integer Index Boolean : (-PS (-is-type 0 Index) -tt))
       (-> Index Nonnegative-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Index))))
       ;; general integer cases
       (-> Positive-Integer Integer Boolean : (-PS (-is-type 1 Positive-Fixnum) -tt))
       (-> Integer Nonnegative-Integer Boolean : (-PS -tt (-is-type 0 Positive-Fixnum)))
       (-> Nonnegative-Integer Integer Boolean : (-PS (-is-type 1 Nonnegative-Fixnum) -tt))
       (-> Integer Negative-Integer Boolean : (-PS (-is-type 0 Negative-Fixnum) -tt))
       (-> Integer Nonpositive-Integer Boolean : (-PS (-is-type 0 Nonpositive-Fixnum) -tt))
       (-> Nonpositive-Integer Integer Boolean : (-PS -tt (-is-type 1 Negative-Fixnum)))
       (comp Integer))))
  (define fx>=-type
    (lambda ()
      (fx-from-cases
       (-> One Integer Boolean : (-PS (-is-type 1 (union One Nonpositive-Integer)) (-is-type 1 Positive-Fixnum)))
       (-> Integer One Boolean : (-PS (-is-type 0 Positive-Fixnum) (-is-type 0 Nonpositive-Fixnum)))
       (-> Zero Integer Boolean : (-PS (-is-type 1 Nonpositive-Fixnum) (-is-type 1 Positive-Fixnum)))
       (-> Integer Zero Boolean : (-PS (-is-type 0 Nonnegative-Fixnum) (-is-type 0 Negative-Fixnum)))

       (-> Byte Positive-Byte Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
       (-> Byte Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
       (-> Byte -Pos Boolean : (-PS (-and (-is-type 1 Positive-Byte) (-is-type 0 Positive-Byte)) -tt))
       (-> -Pos Byte Boolean : (-PS -tt (-and (-is-type 1 Positive-Byte) (-is-type 0 Positive-Byte))))
       (-> Byte Nonnegative-Integer Boolean : (-PS (-is-type 1 Byte) -tt))
       (-> Zero Index Boolean : (-PS (-is-type 1 Zero) (-is-type 1 Positive-Index)))
       (-> Index Positive-Index Boolean : (-PS (-is-type 0 Positive-Index) -tt))
       (-> Index Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
       (-> Index -Pos Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
       (-> -Pos Index Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
       (-> Index Nonnegative-Integer Boolean : (-PS (-is-type 1 Index) -tt))
       (-> Nonnegative-Integer Byte Boolean : (-PS -tt (-and (-is-type 0 Byte) (-is-type 1 Positive-Byte))))
       (-> Nonnegative-Integer Index Boolean : (-PS -tt (-and (-is-type 0 Index) (-is-type 1 Positive-Index))))
       ;; general integer cases
       (-> Integer Positive-Integer Boolean : (-PS (-is-type 0 Positive-Fixnum) -tt))
       (-> Nonnegative-Integer Integer Boolean : (-PS -tt (-is-type 1 Positive-Fixnum)))
       (-> Integer Nonnegative-Integer Boolean : (-PS (-is-type 0 Nonnegative-Fixnum) -tt))
       (-> Negative-Integer Integer Boolean : (-PS (-is-type 1 Negative-Fixnum) -tt))
       (-> Nonpositive-Integer Integer Boolean : (-PS (-is-type 1 Nonpositive-Fixnum) -tt))
       (-> Integer Nonpositive-Integer Boolean : (-PS -tt (-is-type 0 Negative-Fixnum)))
       (comp Integer))))
  (define fxmin-type
    (lambda ()
      (fx-from-cases
       (-> Nonnegative-Integer Nonpositive-Integer Nonpositive-Fixnum : -true-propset : (-arg-path 1))
       (-> Nonpositive-Integer Nonnegative-Integer Nonpositive-Fixnum : -true-propset : (-arg-path 0))
       (-> Zero Integer Nonpositive-Fixnum)
       (-> Integer Zero Nonpositive-Fixnum)

       (commutative-binop Positive-Byte Positive-Integer Positive-Byte)
       (commutative-binop Byte Nonnegative-Integer Byte)
       (commutative-binop Positive-Index Positive-Integer Positive-Index)
       (commutative-binop Index Nonnegative-Integer Index)
       (-> -Pos -Pos Positive-Fixnum)
       (-> Nonnegative-Integer Nonnegative-Integer Nonnegative-Fixnum)
       (commutative-binop Negative-Integer Integer Negative-Fixnum)
       (commutative-binop Nonpositive-Integer Integer Nonpositive-Integer)
       (-> Integer Integer Fixnum))))
  (define fxmax-type
    (lambda ()
      (fx-from-cases
       (-> Nonpositive-Integer Nonnegative-Integer Nonnegative-Fixnum : -true-propset : (-arg-path 1))
       (-> Nonnegative-Integer Nonpositive-Integer Nonnegative-Fixnum : -true-propset : (-arg-path 0))
       (-> Zero Integer Nonnegative-Fixnum)
       (-> Integer Zero Nonnegative-Fixnum)

       (commutative-binop Positive-Byte Byte Positive-Byte)
       (binop Byte)
       (commutative-binop Positive-Index Index Positive-Index)
       (map binop (list Index Negative-Fixnum Nonpositive-Fixnum))
       (commutative-binop Positive-Integer Integer Positive-Fixnum)
       (commutative-binop Nonnegative-Integer Integer Nonnegative-Fixnum)
       (-> Integer Integer Fixnum))))
  (define fxand-type
    (lambda ()
      (fx-from-cases
       (commutative-binop Zero Integer Zero)
       (commutative-binop Byte Integer Byte)
       (commutative-binop Index Integer Index)
       (binop Nonnegative-Integer Nonnegative-Fixnum)
       (binop Negative-Integer Negative-Fixnum)
       (binop Nonpositive-Integer Nonpositive-Fixnum)
       (binop Integer Fixnum))))
  (define fxior-type
    (lambda ()
      (fx-from-cases
       (-> Zero Integer Fixnum : -true-propset : (-arg-path 1))
       (-> Integer Zero Fixnum : -true-propset : (-arg-path 0))

       (commutative-binop Positive-Byte Byte Positive-Byte)
       (binop Byte)
       (commutative-binop Positive-Index Index Positive-Index)
       (binop Index)
       (commutative-binop Positive-Integer Nonnegative-Integer Positive-Fixnum)
       (binop Nonnegative-Integer Nonnegative-Fixnum)
       (commutative-binop Negative-Integer Integer Negative-Fixnum) ; as long as there's one negative, the result is negative
       (binop Integer Fixnum))))
  (define fxxor-type
    (lambda ()
      (fx-from-cases
       (-> Zero Integer Fixnum : -true-propset : (-arg-path 1))
       (-> Integer Zero Fixnum : -true-propset : (-arg-path 0))

       (binop One Zero)
       (binop Byte)
       (binop Index)
       (binop Nonnegative-Integer Nonnegative-Fixnum)
       (binop Nonpositive-Integer Nonnegative-Fixnum)
       (commutative-binop Negative-Integer Nonnegative-Integer Negative-Fixnum)
       (commutative-binop Nonpositive-Integer Nonnegative-Integer Nonpositive-Fixnum)
       (binop Integer Fixnum))))
  (define fxnot-type
    (lambda ()
      (fx-from-cases
       (Nonnegative-Integer . -> . Negative-Fixnum)
       (Negative-Integer . -> . Nonnegative-Fixnum)
       (Integer . -> . Fixnum))))
  (define fxlshift-type
    (lambda ()
      (fx-from-cases
       (-> Integer Zero Fixnum : -true-propset : (-arg-path 0))
       (-> Positive-Integer Integer Positive-Fixnum) ; negative 2nd arg errors, so we can't reach 0
       (-> Nonnegative-Integer Integer Nonnegative-Fixnum)
       (-> Negative-Integer Integer Negative-Fixnum)
       (-> Nonpositive-Integer Integer Nonpositive-Fixnum)
       (binop Integer Fixnum))))
  (define fxrshift-type
    (lambda ()
      (fx-from-cases
       (-> Integer Zero Fixnum : -true-propset : (-arg-path 0))
       (-> Nonnegative-Integer Integer Nonnegative-Fixnum) ; can reach 0
       (-> Negative-Integer Integer Negative-Fixnum) ; can't reach 0
       (-> Nonpositive-Integer Integer Nonpositive-Fixnum)
       (binop Integer Fixnum))))

  ;; A bit of machinery to allow floating point operations to be abstracted over double/extended
  ;; floating point types without repetition. 
  (define-syntax (define-fl-type-lambda stx)
    (define-syntax-class fl-parameter
      (pattern (generic-name:id flonum-name:id extflonum-name:id)
        #:with get-value (generate-temporary #'generic-name)
        #:with definitions 
          #'(begin
              (define (get-value)
                (case (fl-type)
                  [(flonum) flonum-name]
                  [(ext-flonum) extflonum-name]
                  [else (error 'generic-name "Cannot use an fl-type outside of fl-type-lambda")]))
              (define-syntax generic-name 
                (syntax-id-rules ()
                 [_ (get-value)])))))

    (syntax-parse stx
      [(_ name:id (params:fl-parameter ...))
       (quasisyntax/loc stx
         (begin
           (define fl-type (make-parameter #f))
           params.definitions ...
           (define-syntax (name stx)
             (syntax-case stx ()
               ([_ body]
                (syntax/loc stx
                  (lambda (type)
                    (unless (memq type '(flonum ext-flonum))
                      (raise-argument-error 'fl-type-lambda "(or/c 'flonum 'ext-flonum)"))
                    (parameterize ([fl-type type])
                      body))))))))]))

  (define-fl-type-lambda fl-type-lambda
    [(-FlZero    Float-Zero    -ExtFlonumZero)
     (-FlPosZero Float-Positive-Zero -ExtFlonumPosZero)
     (-FlNegZero Float-Negative-Zero -ExtFlonumNegZero)
     (-FlNan     Float-NaN     -ExtFlonumNan)
     (-PosFl     Positive-Float     -PosExtFlonum)
     (-NegFl     Negative-Float     -NegExtFlonum)
     (-NonNegFl  Nonnegative-Float  -NonNegExtFlonum)
     (-NonPosFl  Nonpositive-Float  -NonPosExtFlonum)
     (-Fl        Float        -ExtFlonum)])


  (define flabs-type
    (fl-type-lambda
      (cl->* (-> -FlZero -FlZero)
             (-> (union -PosFl -NegFl) -PosFl)
             (-> -Fl -NonNegFl))))
  (define fl+-type
    (fl-type-lambda
      (from-cases (map (lambda (t) (commutative-binop t -FlZero t))
                       ;; not all float types. singleton types are ruled out, since NaN can arise
                       (list -FlZero -FlNan -PosFl -NonNegFl
                             -NegFl -NonPosFl -Fl))
                  (commutative-binop -NonNegFl -PosFl -PosFl)
                  (map binop (list -NonNegFl -NegFl -NonPosFl -Fl)))))
  (define fl--type
    (fl-type-lambda
      (from-cases (binop -FlZero)
                  (-NegFl -NonNegFl . -> . -NegFl)
                  (-NonPosFl -PosFl . -> . -NegFl)
                  (-NonPosFl -NonNegFl . -> . -NonPosFl)
                  (-PosFl -NonPosFl . -> . -PosFl)
                  (-NonNegFl -NegFl . -> . -PosFl)
                  (-NonNegFl -NonPosFl . -> . -NonNegFl)
                  (binop -Fl))))
  (define fl*-type
    (fl-type-lambda
      (from-cases (binop -FlZero)
                  ;; we don't have Pos Pos -> Pos, possible underflow
                  (binop -NonNegFl)
                  (commutative-binop -NegFl -PosFl -NonPosFl)
                  (binop -NegFl -NonNegFl)
                  (binop -Fl))))
  (define fl/-type
    (fl-type-lambda
      (from-cases (-FlZero -Fl . -> . -FlZero)
                  ;; we don't have Pos Pos -> Pos, possible underflow
                  (-PosFl -PosFl . -> . -NonNegFl)
                  (commutative-binop -PosFl -NegFl -NonPosFl)
                  (-NegFl -NegFl . -> . -NonNegFl)
                  (binop -Fl))))
  (define fl=-type
    (fl-type-lambda
      (from-cases (commutative-equality/strict-prop -Fl (union -FlPosZero -FlNegZero))
                  (map (lambda (t) (commutative-equality/prop -Fl t))
                       (list -FlZero -PosFl -NonNegFl
                             -NegFl -NonPosFl))
                  (comp -Fl))))
  (define fl<-type
    (fl-type-lambda
      (from-cases
       ;; false case, we know nothing, lhs may be NaN. same for all comparison that can involve floats
       (-> -NonNegFl -Fl Boolean : (-PS (-is-type 1 -PosFl) -tt))
       (-> -Fl -NonPosFl Boolean : (-PS (-is-type 0 -NegFl) -tt))
       (comp -Fl))))
  (define fl>-type
    (fl-type-lambda
      (from-cases
       (-> -NonPosFl -Fl Boolean : (-PS (-is-type 1 -NegFl) -tt))
       (-> -Fl -NonNegFl Boolean : (-PS (-is-type 0 -PosFl) -tt))
       (comp -Fl))))
  (define fl<=-type
    (fl-type-lambda
      (from-cases
       (-> -PosFl -Fl Boolean : (-PS (-is-type 1 -PosFl) -tt))
       (-> -NonNegFl -Fl Boolean : (-PS (-is-type 1 -NonNegFl) -tt))
       (-> -Fl -NegFl Boolean : (-PS (-is-type 0 -NegFl) -tt))
       (-> -Fl -NonPosFl Boolean : (-PS (-is-type 0 -NonPosFl) -tt))
       (comp -Fl))))
  (define fl>=-type
    (fl-type-lambda
      (from-cases
       (-> -Fl -PosFl Boolean : (-PS (-is-type 0 -PosFl) -tt))
       (-> -Fl -NonNegFl Boolean : (-PS (-is-type 0 -NonNegFl) -tt))
       (-> -NegFl -Fl Boolean : (-PS (-is-type 1 -NegFl) -tt))
       (-> -NonPosFl -Fl Boolean : (-PS (-is-type 1 -NonPosFl) -tt))
       (comp -Fl))))
  (define flmin-type
    (fl-type-lambda
      (from-cases (commutative-binop -Fl -NegFl)
                  (commutative-binop -Fl -NonPosFl)
                  (map binop (list -PosFl -NonNegFl -Fl)))))
  (define flmax-type
    (fl-type-lambda
      (from-cases (commutative-binop -Fl -PosFl)
                  (commutative-binop -Fl -NonNegFl)
                  (map binop (list -NegFl -NonPosFl -Fl)))))
  (define flround-type ; truncate too
    (fl-type-lambda
      (from-cases (map unop (list -FlPosZero -FlNegZero -FlZero
                                  -NonNegFl -NonPosFl -Fl)))))
  (define flfloor-type
    (fl-type-lambda
      (from-cases (map unop (list -FlPosZero -FlNegZero -FlZero
                                  -NonNegFl -NegFl -NonPosFl -Fl)))))
  (define flceiling-type
    (fl-type-lambda
      (from-cases (map unop (list -FlPosZero -FlNegZero -FlZero
                                  -PosFl -NonNegFl -NonPosFl -Fl)))))
  (define fllog-type
    (fl-type-lambda
      (from-cases (-> -FlZero -NegFl) ; -inf
                  (unop -Fl))))
  (define flexp-type
    (fl-type-lambda
      (from-cases (-NonNegFl . -> . -PosFl)
                  (-Fl . -> . -NonNegFl))))
  (define flsqrt-type
    (fl-type-lambda
      (from-cases (map unop (list -FlPosZero -FlNegZero -FlZero -PosFl))
                  (-Fl . -> . -NonNegFl))))

  (define flexpt-type
    (fl-type-lambda
      (from-cases (-FlZero -PosFl . -> . -FlZero) ; (flexpt -0.0 0.1) -> 0.0 ; not sign preserving
                  ((union -PosFl -NegFl) -FlZero . -> . -PosFl) ; always returns 1.0
                  ;; can underflow, and -0.0 breaks sign, so 1st arg can't be non-neg
                  (-PosFl -Fl . -> . -NonNegFl)
                  (-Fl -Fl . -> . -Fl))))

  (define fx->fl-type
    (fl-type-lambda
      (fx-from-cases
       (Positive-Integer . -> . -PosFl)
       (Nonnegative-Integer . -> . -NonNegFl)
       (Negative-Integer . -> . -NegFl)
       (Nonpositive-Integer . -> . -NonPosFl)
       (Integer . -> . -Fl))))
  (define fl->fx-type
    (fl-type-lambda
      (from-cases
       (-FlZero . -> . Zero)
       (-PosFl . -> . Positive-Fixnum)
       (-NegFl . -> . Negative-Fixnum)
       (-NonNegFl . -> . Nonnegative-Fixnum)
       (-NonPosFl . -> . Nonpositive-Fixnum)
       (-Fl . -> . Fixnum))))
  (define make-flrectangular-type (lambda () (Float Float . -> . Float-Complex)))
  (define flreal-part-type (lambda () (Float-Complex . -> . Float)))
  (define flimag-part-type (lambda () (Float-Complex . -> . Float)))
  (define flrandom-type (lambda () (-Pseudo-Random-Generator . -> . Float)))

  ;; There's a repetitive pattern in the types of each comparison operator.
  ;; As explained below, this is because props don't do intersections.
  ;; Cases that may include NaN don't learn anything when a comparison returns
  ;; false, because anything at all compared to NaN is always false.
  (define (<-type-pattern base pos non-neg neg non-pos [zero Real-Zero]
                          #:no-false-props? [no-false-props? #f])
    (define (-PS* t f) (-PS t (if no-false-props? -tt f)))
    (list (-> base zero Boolean : (-PS* (-is-type 0 neg) (-is-type 0 non-neg)))
          (-> zero base Boolean : (-PS* (-is-type 1 pos) (-is-type 1 non-pos)))
          (-> base Positive-Real Boolean : (-PS* -tt (-is-type 0 pos)))
          (-> base Nonnegative-Real Boolean : (-PS* -tt (-is-type 0 non-neg)))
          (-> Nonnegative-Real base Boolean : (-PS* (-is-type 1 pos) -tt))
          (-> base Nonpositive-Real Boolean : (-PS* (-is-type 0 neg) -tt))
          (-> Negative-Real base Boolean : (-PS* -tt (-is-type 1 neg)))
          (-> Nonpositive-Real base Boolean : (-PS* -tt (-is-type 1 non-pos)))))
  (define (>-type-pattern base pos non-neg neg non-pos [zero Real-Zero]
                          #:no-false-props? [no-false-props? #f])
    (define (-PS* t f) (-PS t (if no-false-props? -tt f)))
    (list (-> base zero Boolean : (-PS* (-is-type 0 pos) (-is-type 0 non-pos)))
          (-> zero base Boolean : (-PS* (-is-type 1 neg) (-is-type 1 non-neg)))
          (-> base Nonnegative-Real Boolean : (-PS* (-is-type 0 pos) -tt))
          (-> Positive-Real base Boolean : (-PS* -tt (-is-type 1 pos)))
          (-> Nonnegative-Real base Boolean : (-PS* -tt (-is-type 1 non-neg)))
          (-> Nonpositive-Real base Boolean : (-PS* (-is-type 1 neg) -tt))
          (-> base Negative-Real Boolean : (-PS* -tt (-is-type 0 neg)))
          (-> base Nonpositive-Real Boolean : (-PS* -tt (-is-type 0 non-pos)))))
  ;; this is > with flipped props
  (define (<=-type-pattern base pos non-neg neg non-pos [zero Real-Zero]
                           #:no-false-props? [no-false-props? #f])
    (define (-PS* t f) (-PS t (if no-false-props? -tt f)))
    (list (-> base zero Boolean : (-PS* (-is-type 0 non-pos) (-is-type 0 pos)))
          (-> zero base Boolean : (-PS* (-is-type 1 non-neg) (-is-type 1 neg)))
          (-> base Nonnegative-Real Boolean : (-PS* -tt (-is-type 0 pos)))
          (-> Positive-Real base Boolean : (-PS* (-is-type 1 pos) -tt))
          (-> Nonnegative-Real base Boolean : (-PS* (-is-type 1 non-neg) -tt))
          (-> Nonpositive-Real base Boolean : (-PS* -tt (-is-type 1 neg)))
          (-> base Negative-Real Boolean : (-PS* (-is-type 0 neg) -tt))
          (-> base Nonpositive-Real Boolean : (-PS* (-is-type 0 non-pos) -tt))))
  (define (>=-type-pattern base pos non-neg neg non-pos [zero Real-Zero]
                           #:no-false-props? [no-false-props? #f])
    (define (-PS* t f) (-PS t (if no-false-props? -tt f)))
    (list (-> base zero Boolean : (-PS* (-is-type 0 non-neg) (-is-type 0 neg)))
          (-> zero base Boolean : (-PS* (-is-type 1 non-pos) (-is-type 1 pos)))
          (-> base Positive-Real Boolean : (-PS* (-is-type 0 pos) -tt))
          (-> base Nonnegative-Real Boolean : (-PS* (-is-type 0 non-neg) -tt))
          (-> Nonnegative-Real base Boolean : (-PS* -tt (-is-type 1 pos)))
          (-> base Nonpositive-Real Boolean : (-PS* -tt (-is-type 0 neg)))
          (-> Negative-Real base Boolean : (-PS* (-is-type 1 neg) -tt))
          (-> Nonpositive-Real base Boolean : (-PS* (-is-type 1 non-pos) -tt))))

  (define (negation-pattern pos neg non-neg non-pos)
    (list (-> pos neg)
          (-> non-neg non-pos)
          (-> neg pos)
          (-> non-pos non-neg)
          (-> Zero pos neg)
          (-> Zero non-neg non-pos)
          (-> Zero neg pos)
          (-> Zero non-pos non-neg)))

  ;; Used because (- min-fixnum) > max-fixnum
  (define (half-negation-pattern pos neg non-neg non-pos)
    (list (-> pos neg)
          (-> non-neg non-pos)
          (-> Zero pos neg)
          (-> Zero non-neg non-pos)))

  (define abs-cases ; used both for abs and magnitude
    (list
     ;; abs is not the identity on negative zeros.
     ((union Zero Positive-Real) . -> . (union Zero Positive-Real) : -true-propset : (-arg-path 0))
     ;; but we know that we at least get *some* zero, and that it preserves exactness
     (map unop (list Float-Zero Single-Float-Zero Real-Zero))
     ;; abs may not be closed on fixnums. (abs min-fixnum) is not a fixnum
     ((union Positive-Integer Negative-Integer) . -> . Positive-Integer)
     (Integer . -> . Nonnegative-Integer)
     ((union Positive-Rational Negative-Rational) . -> . Positive-Rational)
     (Rational . -> . Nonnegative-Rational)
     ((union Positive-Float Negative-Float) . -> . Positive-Float)
     (Float . -> . Nonnegative-Float)
     ((union Positive-Single-Float Negative-Single-Float) . -> . Positive-Single-Float)
     (Single-Float . -> . Nonnegative-Single-Float)
     ((union Positive-Inexact-Real Negative-Inexact-Real) . -> . Positive-Inexact-Real)
     (Inexact-Real . -> . Nonnegative-Inexact-Real)
     ((union Positive-Real Negative-Real) . -> . Positive-Real)
     (Real . -> . Nonnegative-Real)))

  ;Check to ensure we fail fast if the flonum bindings change
  (define-namespace-anchor anchor)
  (let ((flonum-ops #'([unsafe-flround    flround]
                       [unsafe-flfloor    flfloor]
                       [unsafe-flceiling  flceiling]
                       [unsafe-fltruncate fltruncate]
                       [unsafe-flsin      flsin]
                       [unsafe-flcos      flcos]
                       [unsafe-fltan      fltan]
                       [unsafe-flatan     flatan]
                       [unsafe-flasin     flasin ]
                       [unsafe-flacos     flacos]
                       [unsafe-fllog      fllog]
                       [unsafe-flexp      flexp]
                       [unsafe-flexpt     flexpt]
                       [unsafe-extflround    extflround]
                       [unsafe-extflfloor    extflfloor]
                       [unsafe-extflceiling  extflceiling]
                       [unsafe-extfltruncate extfltruncate]
                       [unsafe-extflsin      extflsin]
                       [unsafe-extflcos      extflcos]
                       [unsafe-extfltan      extfltan]
                       [unsafe-extflatan     extflatan]
                       [unsafe-extflasin     extflasin]
                       [unsafe-extflacos     extflacos]
                       [unsafe-extfllog      extfllog]
                       [unsafe-extflexp      extflexp]
                       [unsafe-extflexpt     extflexpt])))
    (define phase (namespace-base-phase (namespace-anchor->namespace anchor)))

    (for ([op-pair (in-syntax flonum-ops)])
      (match op-pair
       [(app syntax->list (list id1 id2))
        (unless (free-identifier=? id1 id2 (sub1 phase))
          (error 'flonum-operations "The assumption that the safe and unsafe flonum-ops are the same binding has been violated. ~a and ~a are diffferent bindings." id1 id2))])))

  )

;; numeric predicates
;; There are 25 values that answer true to zero?. They are either reals, or inexact complexes.
;; Note Real-Zero contains NaN and zero? returns #f on it
[zero?
  (-> Number Boolean : (-PS (-is-type 0 (union Real-ZeroNoNan Inexact-Complex -InexactImaginary))
                 (-not-type 0 Real-ZeroNoNan)))]

[number? (make-pred-ty Number)]
[integer? (asym-pred Any Boolean (-PS (-is-type 0 (union Integer Float Single-Float)) ; inexact-integers exist...
                                 (-not-type 0 Integer)))]
[exact-integer? (make-pred-ty Integer)]
[real? (make-pred-ty Real)]
[flonum? (make-pred-ty Float)]
[single-flonum? (make-pred-ty Single-Float)]
[double-flonum? (make-pred-ty Float)]
[inexact-real? (make-pred-ty Inexact-Real)]
[complex? (make-pred-ty Number)]
;; `rational?' includes all Reals, except infinities and NaN.
[rational? (asym-pred Any Boolean (-PS (-is-type 0 Real) (-not-type 0 Rational)))]
[exact? (make-pred-ty Exact-Number)]
[inexact? (make-pred-ty (union Inexact-Real -InexactImaginary Inexact-Complex))]
[fixnum? (make-pred-ty Fixnum)]
[index? (make-pred-ty Index)]
[positive? (-> Real Boolean : (-PS (-is-type 0 Positive-Real) (-is-type 0 Nonpositive-Real)))]
[negative? (-> Real Boolean : (-PS (-is-type 0 Negative-Real) (-is-type 0 Nonnegative-Real)))]
[exact-positive-integer? (make-pred-ty -Pos)]
[exact-nonnegative-integer? (make-pred-ty Nonnegative-Integer)]

[odd? (-> Integer Boolean : (-PS (-not-type 0 Zero) (-not-type 0 One)))]
[even? (-> Integer Boolean : (-PS (-not-type 0 One) (-not-type 0 Zero)))]

[=
 (from-cases
   (-> Real Real-Zero Boolean : (-PS (-is-type 0 Real-ZeroNoNan) (-not-type 0 Real-ZeroNoNan)))
   (-> Real-Zero Real Boolean : (-PS (-is-type 1 Real-ZeroNoNan) (-not-type 1 Real-ZeroNoNan)))
  (map (lambda (t) (commutative-equality/prop Exact-Number t))
       (list One Positive-Byte Byte Positive-Index Index
             Positive-Fixnum Nonnegative-Fixnum Negative-Fixnum Nonpositive-Fixnum Fixnum
             Positive-Integer Nonnegative-Integer Negative-Integer Nonpositive-Integer Integer
             Positive-Rational Nonnegative-Rational Negative-Rational Nonpositive-Rational Rational
             Exact-Number))
  ;; For all real types: the props give sign information, and the exactness information is preserved
  ;; from the original types.
  (map (lambda (t) (commutative-equality/prop Real t))
       (list Real-Zero Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real Real))
  (->* (list Number Number) Number B))]

[<  (from-cases
     (-> Integer One Boolean : (-PS (-is-type 0 Nonpositive-Integer) (-is-type 0 Positive-Integer)))
     (-> Real Zero Boolean : (-PS (-is-type 0 Negative-Real) (-is-type 0 Nonnegative-Real)))
     (-> Zero Real Boolean : (-PS (-is-type 1 Positive-Real) (-is-type 1 Nonpositive-Real)))
     (-> Real Real-Zero Boolean : (-PS (-is-type 0 Negative-Real) -tt)) ;; False says nothing because of NaN
     (-> Real-Zero Real Boolean : (-PS (-is-type 1 Positive-Real) -tt)) ;; False says nothing because of NaN
     (-> Byte Positive-Byte Boolean : (-PS -tt (-is-type 0 Positive-Byte)))
     (-> Byte Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt))
     (-> Positive-Integer Byte Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
     (-> Positive-Real Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt)) ; Positive-Real is ok here, no prop for #f
     (-> Byte Positive-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
     (-> Byte Positive-Rational Boolean : (-PS -tt (-is-type 0 Positive-Byte))) ; can't be Positive-Real, which includes NaN
     (-> Nonnegative-Integer Byte Boolean : (-PS (-and (-is-type 0 Byte) (-is-type 1 Positive-Byte)) -tt))
     (-> Nonnegative-Real Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt))
     (-> Byte Nonnegative-Integer Boolean : (-PS -tt (-is-type 1 Byte)))
     (-> Index Positive-Index Boolean : (-PS -tt (-is-type 0 Positive-Index)))
     (-> Index Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
     (-> Positive-Integer Index Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
     (-> Positive-Real Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
     (-> Index Positive-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
     (-> Index Positive-Rational Boolean : (-PS -tt (-is-type 0 Positive-Index))) ; can't be Positive-Real, which includes NaN
     (-> Nonnegative-Integer Index Boolean : (-PS (-and (-is-type 0 Index) (-is-type 1 Positive-Index)) -tt))
     (-> Nonnegative-Real Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
     (-> Index Nonnegative-Integer Boolean : (-PS -tt (-is-type 1 Index)))
     (-> Fixnum Positive-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Fixnum) (-is-type 1 Positive-Fixnum))))
     (-> Fixnum Positive-Rational Boolean : (-PS -tt (-is-type 0 Positive-Fixnum)))
     (-> Fixnum Nonnegative-Integer Boolean : (-PS -tt (-and (-is-type 0 Nonnegative-Fixnum) (-is-type 1 Nonnegative-Fixnum))))
     (-> Fixnum Nonnegative-Rational Boolean : (-PS -tt (-is-type 0 Nonnegative-Fixnum)))
     (-> Nonnegative-Integer Fixnum Boolean : (-PS (-and (-is-type 1 Positive-Fixnum) (-is-type 0 Nonnegative-Fixnum)) -tt))
     (-> Nonnegative-Real Fixnum Boolean : (-PS (-is-type 1 Positive-Fixnum) -tt))
     (-> Fixnum Nonpositive-Integer Boolean : (-PS (-and (-is-type 0 Negative-Fixnum) (-is-type 1 Nonpositive-Fixnum)) -tt))
     (-> Fixnum Nonpositive-Real Boolean : (-PS (-is-type 0 Negative-Fixnum) -tt))
     (-> Negative-Integer Fixnum Boolean : (-PS -tt (-and (-is-type 0 Negative-Fixnum) (-is-type 1 Negative-Fixnum))))
     (-> Negative-Rational Fixnum Boolean : (-PS -tt (-is-type 1 Negative-Fixnum)))
     (-> Nonpositive-Integer Fixnum Boolean : (-PS -tt (-and (-is-type 0 Nonpositive-Fixnum) (-is-type 1 Nonpositive-Fixnum))))
     (-> Nonpositive-Rational Fixnum Boolean : (-PS -tt (-is-type 1 Nonpositive-Fixnum)))
     (-> Real -PosInfinity Boolean : (-PS (-not-type 0 (union Inexact-Real-NaN -PosInfinity))
                                     (-is-type 0 (union Inexact-Real-NaN -PosInfinity))))
     (-> -NegInfinity Real Boolean : (-PS (-not-type 1 (union Inexact-Real-NaN -NegInfinity))
                                     (-is-type 1 (union Inexact-Real-NaN -NegInfinity))))
     (-> -PosInfinity Real Boolean : -false-propset)
     (-> Real -NegInfinity Boolean : -false-propset)
     ;; If applying props resulted in the interesection of the prop and the
     ;; original type, we'd only need the cases for Fixnums and those for Reals.
     ;; Cases for Integers and co would fall out naturally from the Real cases,
     ;; since we'd keep track of the representation knowledge we'd already have,
     ;; and the Real cases are enough to give us sign information.
     ;; In the meantime, repetition is hard to avoid.
     (<-type-pattern Integer Positive-Integer Nonnegative-Integer Negative-Integer Nonpositive-Integer Zero)
     (<-type-pattern Rational Positive-Rational Nonnegative-Rational Negative-Rational Nonpositive-Rational Zero)
     (<-type-pattern Float Positive-Float Nonnegative-Float Negative-Float Nonpositive-Float #:no-false-props? #t)
     (<-type-pattern Single-Float Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float #:no-false-props? #t)
     (<-type-pattern Inexact-Real Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real #:no-false-props? #t)
     (<-type-pattern Real Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real #:no-false-props? #t)
     (->* (list R R) R B))]
[>  (from-cases
     (-> One Integer Boolean : (-PS (-is-type 1 Nonpositive-Integer) (-is-type 1 Positive-Integer)))
     (-> Real Zero Boolean : (-PS (-is-type 0 Positive-Real) (-is-type 0 Nonpositive-Real)))
     (-> Zero Real Boolean : (-PS (-is-type 1 Negative-Real) (-is-type 1 Nonnegative-Real)))
     (-> Real Real-Zero Boolean : (-PS (-is-type 0 Positive-Real) -tt)) ;; False says nothing because of NaN
     (-> Real-Zero Real Boolean : (-PS (-is-type 1 Negative-Real) -tt)) ;; False says nothing because of NaN
     (-> Positive-Byte Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
     (-> Byte Byte Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
     (-> Byte Positive-Integer Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
     (-> Byte Positive-Real Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
     (-> Positive-Integer Byte Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
     (-> Positive-Rational Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
     (-> Byte Nonnegative-Integer Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Byte)) -tt))
     (-> Byte Nonnegative-Real Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
     (-> Nonnegative-Integer Byte Boolean : (-PS -tt (-is-type 0 Byte)))
     (-> Positive-Index Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
     (-> Index Index Boolean : (-PS (-is-type 0 Positive-Index) -tt))
     (-> Index Positive-Integer Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
     (-> Index Positive-Real Boolean : (-PS (-is-type 0 Positive-Index) -tt))
     (-> Positive-Integer Index Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
     (-> Positive-Rational Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
     (-> Index Nonnegative-Integer Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Index)) -tt))
     (-> Index Nonnegative-Real Boolean : (-PS (-is-type 0 Positive-Index) -tt))
     (-> Nonnegative-Integer Index Boolean : (-PS -tt (-is-type 0 Index)))
     (-> Positive-Integer Fixnum Boolean : (-PS -tt (-and (-is-type 0 Positive-Fixnum) (-is-type 1 Positive-Fixnum))))
     (-> Positive-Rational Fixnum Boolean : (-PS -tt (-is-type 1 Positive-Fixnum)))
     (-> Nonnegative-Integer Fixnum Boolean : (-PS -tt (-and (-is-type 0 Nonnegative-Fixnum) (-is-type 1 Nonnegative-Fixnum))))
     (-> Nonnegative-Rational Fixnum Boolean : (-PS -tt (-is-type 1 Nonnegative-Fixnum)))
     (-> Fixnum Nonnegative-Integer Boolean : (-PS (-and (-is-type 0 Positive-Fixnum) (-is-type 1 Nonnegative-Fixnum)) -tt))
     (-> Fixnum Nonnegative-Real Boolean : (-PS (-is-type 0 Positive-Fixnum) -tt))
     (-> Nonpositive-Integer Fixnum Boolean : (-PS (-and (-is-type 0 Nonpositive-Fixnum) (-is-type 1 Negative-Fixnum)) -tt))
     (-> Nonpositive-Real Fixnum Boolean : (-PS (-is-type 1 Negative-Fixnum) -tt))
     (-> Fixnum Negative-Integer Boolean : (-PS -tt (-and (-is-type 0 Negative-Fixnum) (-is-type 1 Negative-Fixnum))))
     (-> Fixnum Negative-Rational Boolean : (-PS -tt (-is-type 0 Negative-Fixnum)))
     (-> Fixnum Nonpositive-Integer Boolean : (-PS -tt (-and (-is-type 0 Nonpositive-Fixnum) (-is-type 1 Nonpositive-Fixnum))))
     (-> Fixnum Nonpositive-Rational Boolean : (-PS -tt (-is-type 0 Nonpositive-Fixnum)))
     (-> -PosInfinity Real Boolean : (-PS (-not-type 1 (union Inexact-Real-NaN -PosInfinity))
                                     (-is-type 1 (union Inexact-Real-NaN -PosInfinity))))
     (-> Real -NegInfinity Boolean : (-PS (-not-type 0 (union Inexact-Real-NaN -NegInfinity))
                                     (-is-type 0 (union Inexact-Real-NaN -NegInfinity))))
     (-> Real -PosInfinity Boolean : -false-propset)
     (-> -NegInfinity Real Boolean : -false-propset)
     (>-type-pattern Integer Positive-Integer Nonnegative-Integer Negative-Integer Nonpositive-Integer Zero)
     (>-type-pattern Rational Positive-Rational Nonnegative-Rational Negative-Rational Nonpositive-Rational Zero)
     (>-type-pattern Float Positive-Float Nonnegative-Float Negative-Float Nonpositive-Float #:no-false-props? #t)
     (>-type-pattern Single-Float Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float #:no-false-props? #t)
     (>-type-pattern Inexact-Real Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real #:no-false-props? #t)
     (>-type-pattern Real Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real #:no-false-props? #t)
     (->* (list R R) R B))]
[<= (from-cases
     (-> Integer One Boolean : (-PS (-is-type 0 (union Nonpositive-Integer One)) (-is-type 0 Positive-Integer)))
     (-> One Integer Boolean : (-PS (-is-type 1 Positive-Integer) (-is-type 1 Nonpositive-Integer)))
     (-> Real Zero Boolean : (-PS (-is-type 0 Nonpositive-Real) (-is-type 0 Positive-Real)))
     (-> Zero Real Boolean : (-PS (-is-type 1 Nonnegative-Real) (-is-type 1 Negative-Real)))
     (-> Real Real-Zero Boolean : (-PS (-is-type 0 Nonpositive-Real) -tt)) ;; False says nothing because of NaN
     (-> Real-Zero Real Boolean : (-PS (-is-type 0 Nonnegative-Real) -tt)) ;; False says nothing because of NaN
     (-> Positive-Byte Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt))
     (-> Byte Byte Boolean : (-PS -tt (-is-type 0 Positive-Byte)))
     (-> Positive-Integer Byte Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
     (-> Positive-Real Byte Boolean : (-PS (-is-type 1 Positive-Byte) -tt))
     (-> Byte Positive-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
     (-> Byte Positive-Rational Boolean : (-PS -tt (-is-type 0 Positive-Byte)))
     (-> Nonnegative-Integer Byte Boolean : (-PS (-is-type 0 Byte) -tt))
     (-> Byte Nonnegative-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Byte))))
     (-> Byte Nonnegative-Rational Boolean : (-PS -tt (-is-type 0 Positive-Byte)))
     (-> Positive-Index Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
     (-> Index Index Boolean : (-PS -tt (-is-type 0 Positive-Index)))
     (-> -Pos Index Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
     (-> Positive-Real Index Boolean : (-PS (-is-type 1 Positive-Index) -tt))
     (-> Index -Pos Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
     (-> Index Positive-Rational Boolean : (-PS -tt (-is-type 0 Positive-Index)))
     (-> Nonnegative-Integer Index Boolean : (-PS (-is-type 0 Index) -tt))
     (-> Index Nonnegative-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Index))))
     (-> Index Nonnegative-Rational Boolean : (-PS -tt (-is-type 0 Positive-Index)))
     (-> Positive-Integer Fixnum Boolean : (-PS (-and (-is-type 0 Positive-Fixnum) (-is-type 1 Positive-Fixnum)) -tt))
     (-> Positive-Real Fixnum Boolean : (-PS (-is-type 1 Positive-Fixnum) -tt))
     (-> Nonnegative-Integer Fixnum Boolean : (-PS (-and (-is-type 0 Nonnegative-Fixnum) (-is-type 1 Nonnegative-Fixnum)) -tt))
     (-> Nonnegative-Real Fixnum Boolean : (-PS (-is-type 1 Nonnegative-Fixnum) -tt))
     (-> Fixnum Nonnegative-Integer Boolean : (-PS -tt (-and (-is-type 0 Positive-Fixnum) (-is-type 1 Nonnegative-Fixnum))))
     (-> Fixnum Nonnegative-Rational Boolean : (-PS -tt (-is-type 0 Positive-Fixnum)))
     (-> Nonpositive-Integer Fixnum Boolean : (-PS -tt (-and (-is-type 0 Nonpositive-Fixnum) (-is-type 1 Negative-Fixnum))))
     (-> Nonpositive-Rational Fixnum Boolean : (-PS -tt (-is-type 1 Negative-Fixnum)))
     (-> Fixnum Negative-Integer Boolean : (-PS (-and (-is-type 0 Negative-Fixnum) (-is-type 1 Negative-Fixnum)) -tt))
     (-> Fixnum Negative-Real Boolean : (-PS (-is-type 0 Negative-Fixnum) -tt))
     (-> Fixnum Nonpositive-Integer Boolean : (-PS (-and (-is-type 0 Nonpositive-Fixnum) (-is-type 1 Nonpositive-Fixnum)) -tt))
     (-> Fixnum Nonpositive-Real Boolean : (-PS (-is-type 0 Nonpositive-Fixnum) -tt))
     (-> Real -PosInfinity Boolean : (-PS (-not-type 0 Inexact-Real-NaN) (-is-type 0 Inexact-Real-NaN)))
     (-> -NegInfinity Real Boolean : (-PS (-not-type 1 Inexact-Real-NaN) (-is-type 1 Inexact-Real-NaN)))
     (-> -PosInfinity Real Boolean : (-PS (-is-type 1 -PosInfinity) (-not-type 1 -PosInfinity)))
     (-> Real -NegInfinity Boolean : (-PS (-is-type 0 -NegInfinity) (-not-type 0 -NegInfinity)))
     (<=-type-pattern Integer Positive-Integer Nonnegative-Integer Negative-Integer Nonpositive-Integer Zero)
     (<=-type-pattern Rational Positive-Rational Nonnegative-Rational Negative-Rational Nonpositive-Rational Zero)
     (<=-type-pattern Float Positive-Float Nonnegative-Float Negative-Float Nonpositive-Float #:no-false-props? #t)
     (<=-type-pattern Single-Float Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float #:no-false-props? #t)
     (<=-type-pattern Inexact-Real Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real #:no-false-props? #t)
     (<=-type-pattern Real Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real #:no-false-props? #t)
     (->* (list R R) R B))]
[>= (from-cases
     (-> One Integer Boolean : (-PS (-is-type 1 (union One Nonpositive-Integer)) (-is-type 1 Positive-Integer)))
     (-> Integer One Boolean : (-PS (-is-type 0 Positive-Integer) (-is-type 0 Nonpositive-Integer)))
     (-> Real Zero Boolean : (-PS (-is-type 0 Nonnegative-Real) (-is-type 0 Negative-Real)))
     (-> Zero Real Boolean : (-PS (-is-type 1 Nonpositive-Real) (-is-type 1 Positive-Real)))
     (-> Real Real-Zero Boolean : (-PS (-is-type 0 Nonnegative-Real) -tt)) ;; False says nothing because of NaN
     (-> Real-Zero Real Boolean : (-PS (-is-type 0 Nonpositive-Real) -tt)) ;; False says nothing because of NaN
     (-> Byte Positive-Byte Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
     (-> Byte Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
     (-> Byte Positive-Integer Boolean : (-PS (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte)) -tt))
     (-> Byte Positive-Real Boolean : (-PS (-is-type 0 Positive-Byte) -tt))
     (-> Positive-Integer Byte Boolean : (-PS -tt (-and (-is-type 0 Positive-Byte) (-is-type 1 Positive-Byte))))
     (-> Positive-Rational Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
     (-> Byte Nonnegative-Integer Boolean : (-PS (-is-type 1 Byte) -tt))
     (-> Nonnegative-Integer Byte Boolean : (-PS -tt (-and (-is-type 0 Byte) (-is-type 1 Positive-Byte))))
     (-> Nonnegative-Rational Byte Boolean : (-PS -tt (-is-type 1 Positive-Byte)))
     (-> Index Positive-Index Boolean : (-PS (-is-type 0 Positive-Index) -tt))
     (-> Index Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
     (-> Index -Pos Boolean : (-PS (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index)) -tt))
     (-> Index Positive-Real Boolean : (-PS (-is-type 0 Positive-Index) -tt))
     (-> -Pos Index Boolean : (-PS -tt (-and (-is-type 0 Positive-Index) (-is-type 1 Positive-Index))))
     (-> Positive-Rational Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
     (-> Index Nonnegative-Integer Boolean : (-PS (-is-type 1 Index) -tt))
     (-> Nonnegative-Integer Index Boolean : (-PS -tt (-and (-is-type 0 Index) (-is-type 1 Positive-Index))))
     (-> Nonnegative-Rational Index Boolean : (-PS -tt (-is-type 1 Positive-Index)))
     (-> Fixnum Positive-Integer Boolean : (-PS (-and (-is-type 0 Positive-Fixnum) (-is-type 1 Positive-Fixnum)) -tt))
     (-> Fixnum Positive-Real Boolean : (-PS (-is-type 0 Positive-Fixnum) -tt))
     (-> Fixnum Nonnegative-Integer Boolean : (-PS (-and (-is-type 0 Nonnegative-Fixnum) (-is-type 1 Nonnegative-Fixnum)) -tt))
     (-> Fixnum Nonnegative-Real Boolean : (-PS (-is-type 0 Nonnegative-Fixnum) -tt))
     (-> Nonnegative-Integer Fixnum Boolean : (-PS -tt (-and (-is-type 0 Nonnegative-Fixnum) (-is-type 1 Positive-Fixnum))))
     (-> Nonnegative-Rational Fixnum Boolean : (-PS -tt (-is-type 1 Positive-Fixnum)))
     (-> Fixnum Nonpositive-Integer Boolean : (-PS -tt (-and (-is-type 0 Negative-Fixnum) (-is-type 1 Nonpositive-Fixnum))))
     (-> Fixnum Nonpositive-Rational Boolean : (-PS -tt (-is-type 0 Negative-Fixnum)))
     (-> Negative-Integer Fixnum Boolean : (-PS (-and (-is-type 0 Negative-Fixnum) (-is-type 1 Negative-Fixnum)) -tt))
     (-> Negative-Real Fixnum Boolean : (-PS (-is-type 1 Negative-Fixnum) -tt))
     (-> Nonpositive-Integer Fixnum Boolean : (-PS (-and (-is-type 0 Nonpositive-Fixnum) (-is-type 1 Nonpositive-Fixnum)) -tt))
     (-> Nonpositive-Real Fixnum Boolean : (-PS (-is-type 1 Nonpositive-Fixnum) -tt))
     (-> -PosInfinity Real Boolean : (-PS (-not-type 1 Inexact-Real-NaN) (-is-type 1 Inexact-Real-NaN)))
     (-> Real -NegInfinity Boolean : (-PS (-not-type 0 Inexact-Real-NaN) (-is-type 0 Inexact-Real-NaN)))
     (-> Real -PosInfinity Boolean : (-PS (-is-type 0 -PosInfinity) (-not-type 0 -PosInfinity)))
     (-> -NegInfinity Real Boolean : (-PS (-is-type 1 -NegInfinity) (-not-type 1 -NegInfinity)))
     (>=-type-pattern Integer Positive-Integer Nonnegative-Integer Negative-Integer Nonpositive-Integer Zero)
     (>=-type-pattern Rational Positive-Rational Nonnegative-Rational Negative-Rational Nonpositive-Rational Zero)
     (>=-type-pattern Float Positive-Float Nonnegative-Float Negative-Float Nonpositive-Float #:no-false-props? #t)
     (>=-type-pattern Single-Float Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float #:no-false-props? #t)
     (>=-type-pattern Inexact-Real Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real #:no-false-props? #t)
     (>=-type-pattern Real Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real #:no-false-props? #t)
     (->* (list R R) R B))]

[* (from-cases
    (-> One)
    (-> Number Number : -true-propset : (-arg-path 0))
    (commutative-case Zero Number Zero)
    (-> Number One Number : -true-propset : (-arg-path 0))
    (-> One Number Number : -true-propset : (-arg-path 1))
    (-> Positive-Byte Positive-Byte Positive-Index)
    (-> Byte Byte Index)
    (-> Positive-Byte Positive-Byte Positive-Byte Positive-Fixnum)
    (-> Byte Byte Byte Nonnegative-Fixnum)
    (varop Positive-Integer)
    (varop Nonnegative-Integer)
    (-> Negative-Integer Negative-Integer)
    (-> Nonpositive-Integer Nonpositive-Integer)
    (-> Negative-Integer Negative-Integer Positive-Integer)
    (commutative-binop Negative-Integer Positive-Integer Negative-Integer)
    (-> Nonpositive-Integer Nonpositive-Integer Nonnegative-Integer)
    (commutative-binop Nonpositive-Integer Nonnegative-Integer Nonpositive-Integer)
    (-> Negative-Integer Negative-Integer Negative-Integer Negative-Integer)
    (-> Nonpositive-Integer Nonpositive-Integer Nonpositive-Integer Nonpositive-Integer)
    (map varop (list Integer Positive-Rational Nonnegative-Rational))
    (-> Negative-Rational Negative-Rational)
    (-> Nonpositive-Rational Nonpositive-Rational)
    (-> Negative-Rational Negative-Rational Positive-Rational)
    (commutative-binop Negative-Rational Positive-Rational Negative-Rational)
    (-> Nonpositive-Rational Nonpositive-Rational Nonnegative-Rational)
    (commutative-binop Nonpositive-Rational Nonnegative-Rational Nonpositive-Rational)
    (-> Negative-Rational Negative-Rational Negative-Rational Negative-Rational)
    (-> Nonpositive-Rational Nonpositive-Rational Nonpositive-Rational Nonpositive-Rational)
    (varop Rational)
    (varop-1+ Float-Zero)
    ; no pos * -> pos, possible underflow
    (varop-1+ Nonnegative-Float)
    ;; can't do NonPos NonPos -> NonNeg: (* -1.0 0.0) -> NonPos!
    (-> Negative-Float Negative-Float Nonnegative-Float) ; possible underflow, so no neg neg -> pos
    (-> Negative-Float Negative-Float Negative-Float Nonpositive-Float) ; see above
    ;; limited flonum contagion rules
    ;; (* <float> 0) is exact 0 (i.e. not a float)
    (commutative-case Nonnegative-Float Positive-Real) ; real args don't include 0
    (commutative-case Float (union Positive-Real Negative-Real) Float)
    (map varop-1+ (list Float Single-Float-Zero Nonnegative-Single-Float))
    ;; we could add contagion rules for negatives, but we haven't for now
    (-> Negative-Single-Float Negative-Single-Float Nonnegative-Single-Float) ; possible underflow, so no neg neg -> pos
    (-> Negative-Single-Float Negative-Single-Float Negative-Single-Float Nonpositive-Single-Float)
    (commutative-case Nonnegative-Single-Float (union Positive-Rational Nonnegative-Single-Float))
    (commutative-case Single-Float (union Positive-Rational Negative-Rational Single-Float) Single-Float)
    (map varop-1+ (list Single-Float Inexact-Real-Zero Nonnegative-Inexact-Real))
    (-> Negative-Inexact-Real Negative-Inexact-Real Nonnegative-Inexact-Real)
    (-> Negative-Inexact-Real Negative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real)
    (commutative-case Nonnegative-Inexact-Real (union Positive-Rational Nonnegative-Inexact-Real))
    (commutative-case Inexact-Real (union Positive-Rational Negative-Rational Inexact-Real) Inexact-Real)
    (varop-1+ Inexact-Real)
    ;; reals
    (varop Nonnegative-Real) ; (* +inf.0 0.0) -> +nan.0
    (-> Nonpositive-Real Nonpositive-Real Nonnegative-Real)
    (commutative-binop Nonpositive-Real Nonnegative-Real Nonpositive-Real)
    (-> Nonpositive-Real Nonpositive-Real Nonpositive-Real Nonpositive-Real)
    (varop Real)
    ;; complexes
    (commutative-case Float-Complex (union Inexact-Complex Inexact-Real Positive-Rational Negative-Rational) Float-Complex)
    (commutative-case Single-Float-Complex (union Single-Float-Complex Single-Float Positive-Rational Negative-Rational) Single-Float-Complex)
    (commutative-case Inexact-Complex (union Inexact-Complex Inexact-Real Positive-Rational Negative-Rational) Inexact-Complex)
    (varop Number))]
[+ (from-cases
    (-> Zero)
    (-> Number Number : -true-propset : (-arg-path 0))
    (binop Zero)
    (-> Number Zero Number : -true-propset : (-arg-path 0))
    (-> Zero Number Number : -true-propset : (-arg-path 1))
    (-> Positive-Byte Positive-Byte Positive-Index)
    (-> Byte Byte Index)
    (-> Positive-Byte Positive-Byte Positive-Byte Positive-Index)
    (-> Byte Byte Byte Index)
    (commutative-binop Positive-Index Index Positive-Fixnum)
    (-> Positive-Index Index Index Positive-Fixnum)
    (-> Index Positive-Index Index Positive-Fixnum)
    (-> Index Index Positive-Index Positive-Fixnum)
    (-> Index Index Nonnegative-Fixnum)
    (-> Index Index Index Nonnegative-Fixnum)
    (commutative-binop Negative-Fixnum One Nonpositive-Fixnum)
    (commutative-binop Nonpositive-Fixnum Nonnegative-Fixnum Fixnum)
    (commutative-case Positive-Integer Nonnegative-Integer Positive-Integer)
    (commutative-case Negative-Integer Nonpositive-Integer Negative-Integer)
    (map varop (list Nonnegative-Integer Nonpositive-Integer Integer))
    (commutative-case Positive-Rational Nonnegative-Rational Positive-Rational)
    (commutative-case Negative-Rational Nonpositive-Rational Negative-Rational)
    (map varop (list Nonnegative-Rational Nonpositive-Rational Rational))
    ;; flonum + real -> flonum
    (commutative-case Positive-Float Nonnegative-Real Positive-Float)
    (commutative-case Positive-Real Nonnegative-Float Positive-Float)
    (commutative-case Negative-Float Nonpositive-Real Negative-Float)
    (commutative-case Negative-Real Nonpositive-Float Negative-Float)
    (commutative-case Nonnegative-Float Nonnegative-Real Nonnegative-Float)
    (commutative-case Nonpositive-Float Nonpositive-Real Nonpositive-Float)
    (commutative-case Float Real Float)
    (varop-1+ Float)
    ;; single-flonum + rat -> single-flonum
    (commutative-case Positive-Single-Float (union Nonnegative-Rational Nonnegative-Single-Float) Positive-Single-Float)
    (commutative-case (union Positive-Rational Positive-Single-Float) Nonnegative-Single-Float Positive-Single-Float)
    (commutative-case Negative-Single-Float (union Nonpositive-Rational Nonpositive-Single-Float) Negative-Single-Float)
    (commutative-case (union Negative-Rational Negative-Single-Float) Nonpositive-Single-Float Negative-Single-Float)
    (commutative-case Nonnegative-Single-Float (union Nonnegative-Rational Nonnegative-Single-Float) Nonnegative-Single-Float)
    (commutative-case Nonpositive-Single-Float (union Nonpositive-Rational Nonpositive-Single-Float) Nonpositive-Single-Float)
    (commutative-case Single-Float (union Rational Single-Float) Single-Float)
    (varop-1+ Single-Float)
    ;; inexact-real + real -> inexact-real
    (commutative-case Positive-Inexact-Real Nonnegative-Real Positive-Inexact-Real)
    (commutative-case Positive-Real Nonnegative-Inexact-Real Positive-Inexact-Real)
    (commutative-case Negative-Inexact-Real Nonpositive-Real Negative-Inexact-Real)
    (commutative-case Negative-Real Nonpositive-Inexact-Real Negative-Inexact-Real)
    (commutative-case Nonnegative-Inexact-Real Nonnegative-Real Nonnegative-Inexact-Real)
    (commutative-case Nonpositive-Inexact-Real Nonpositive-Real Nonpositive-Inexact-Real)
    (commutative-case Inexact-Real Real Inexact-Real)
    ;; real
    (commutative-case Positive-Real Nonnegative-Real Positive-Real)
    (commutative-case Negative-Real Nonpositive-Real Negative-Real)
    (map varop (list Nonnegative-Real Nonpositive-Real Real Exact-Number))
    ;; complex
    (commutative-case Float-Complex Number Float-Complex)
    (commutative-case Float Inexact-Complex Float-Complex)
    (commutative-case Single-Float-Complex (union Rational Single-Float Single-Float-Complex) Single-Float-Complex)
    (commutative-case Inexact-Complex (union Rational Inexact-Real Inexact-Complex) Inexact-Complex)
    (varop Number))]

[- (from-cases
    (binop Zero)
    (half-negation-pattern Positive-Fixnum Negative-Fixnum Nonnegative-Fixnum Nonpositive-Fixnum)
    (negation-pattern Positive-Integer Negative-Integer Nonnegative-Integer Nonpositive-Integer)
    (negation-pattern Positive-Rational Negative-Rational Nonnegative-Rational Nonpositive-Rational)
    (negation-pattern Positive-Float Negative-Float Nonnegative-Float Nonpositive-Float)
    (negation-pattern Positive-Single-Float Negative-Single-Float Nonnegative-Single-Float Nonpositive-Single-Float)
    (negation-pattern Positive-Inexact-Real Negative-Inexact-Real Nonnegative-Inexact-Real Nonpositive-Inexact-Real)
    (negation-pattern Positive-Real Negative-Real Nonnegative-Real Nonpositive-Real)

    (-> Number Zero Number : -true-propset : (-arg-path 0))
    (-> One One Zero)
    (-> Positive-Byte One Byte)
    (-> Positive-Index One Index)
    (-> Positive-Fixnum One Nonnegative-Fixnum)
    (-> Positive-Integer One Nonnegative-Integer)
    (-> Nonnegative-Fixnum Nonnegative-Fixnum Fixnum)
    (-> Negative-Fixnum Nonpositive-Fixnum Fixnum)
    (->* (list Positive-Integer Nonpositive-Integer) Nonpositive-Integer Positive-Integer)
    (->* (list Nonnegative-Integer Nonpositive-Integer) Nonpositive-Integer Nonnegative-Integer)
    (->* (list Negative-Integer Nonnegative-Integer) Nonnegative-Integer Negative-Integer)
    (->* (list Nonpositive-Integer Nonnegative-Integer) Nonnegative-Integer Nonpositive-Integer)
    (varop-1+ Integer)
    (->* (list Positive-Rational Nonpositive-Rational) Nonpositive-Rational Positive-Rational)
    (->* (list Nonnegative-Rational Nonpositive-Rational) Nonpositive-Rational Nonnegative-Rational)
    (->* (list Negative-Rational Nonnegative-Rational) Nonnegative-Rational Negative-Rational)
    (->* (list Nonpositive-Rational Nonnegative-Rational) Nonnegative-Rational Nonpositive-Rational)
    (varop-1+ Rational)
    ;; floats - uncertain about sign properties in the presence of
    ;; under/overflow, so these are left out
    (varop-1+ Float)
    (commutative-case Float Real Float)
    (varop-1+ Single-Float)
    (commutative-case Single-Float (union Single-Float Rational) Single-Float)
    (varop-1+ Inexact-Real)
    (commutative-case Inexact-Real (union Inexact-Real Rational) Inexact-Real)
    (map varop-1+ (list Real Exact-Number))
    (varop-1+ Float-Complex)
    (commutative-case Float-Complex Number Float-Complex)
    (varop-1+ Single-Float-Complex)
    (commutative-case Single-Float-Complex (union Single-Float-Complex Exact-Number) Single-Float-Complex)
    (varop-1+ Inexact-Complex)
    (commutative-case Inexact-Complex (union Inexact-Complex Exact-Number) Inexact-Complex)
    (varop-1+ Number))]
[/ (from-cases ; very similar to multiplication, without closure properties for integers
    (commutative-case Zero Number Zero)
    (unop One)
    (-> Number One Number : -true-propset : (-arg-path 0))
    (varop-1+ Positive-Rational)
    (varop-1+ Nonnegative-Rational)
    (-> Negative-Rational Negative-Rational)
    (-> Nonpositive-Rational Nonpositive-Rational)
    (-> Negative-Rational Negative-Rational Positive-Rational)
    (commutative-binop Negative-Rational Positive-Rational Negative-Rational)
    (-> Nonpositive-Rational Nonpositive-Rational Nonnegative-Rational)
    (commutative-binop Nonpositive-Rational Nonnegative-Rational Nonpositive-Rational)
    (-> Negative-Rational Negative-Rational Negative-Rational Negative-Rational)
    (-> Nonpositive-Rational Nonpositive-Rational Nonpositive-Rational Nonpositive-Rational)
    (varop-1+ Rational)
    (-> Float-Zero (union Positive-Float Negative-Float)) ; one of the infinities
    ;; No (-> Nonnegative-Float Nonnegative-Float Nonnegative-Float), (/ 0.1 -0.0) => -inf.0
    ;; No (-> Nonpositive-Float Nonpositive-Float), (/ 0.0) => +inf.0
    (-> Negative-Float Negative-Float Nonnegative-Float)
    (-> Negative-Float Negative-Float Negative-Float Nonpositive-Float)
    ;; limited flonum contagion rules
    ;; (/ 0 <float>) is exact 0 (i.e. not a float)
    (commutative-case Positive-Float Positive-Real Nonnegative-Float)
    (->* (list (union Positive-Real Negative-Real Float) Float) Float Float)
    (->* (list Float) Real Float) ; if any argument after the first is exact 0, not a problem
    (varop-1+ Float)
    (-> Single-Float-Zero (union Positive-Single-Float Negative-Single-Float)) ; one of the infinities
    ;; we could add contagion rules for negatives, but we haven't for now
    (-> Negative-Single-Float Negative-Single-Float Nonnegative-Single-Float) ; possible underflow, so no neg neg -> pos
    (-> Negative-Single-Float Negative-Single-Float Negative-Single-Float Nonpositive-Single-Float)
    (commutative-case Positive-Single-Float (union Positive-Rational Positive-Single-Float) Nonnegative-Single-Float)
    (commutative-case Single-Float (union Positive-Rational Negative-Rational Single-Float) Single-Float)
    (varop-1+ Single-Float)
    (-> Inexact-Real-Zero (union Positive-Inexact-Real Negative-Inexact-Real))
    (-> Negative-Inexact-Real Negative-Inexact-Real Nonnegative-Inexact-Real)
    (-> Negative-Inexact-Real Negative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real)
    (commutative-case Positive-Inexact-Real (union Positive-Rational Positive-Inexact-Real) Nonnegative-Inexact-Real)
    (commutative-case Inexact-Real (union Positive-Rational Negative-Rational Inexact-Real) Inexact-Real)
    (varop-1+ Inexact-Real)
    ;; reals
    (varop-1+ Positive-Real Nonnegative-Real)
    (-> Nonpositive-Real Nonpositive-Real)
    (-> Negative-Real Negative-Real Nonnegative-Real) ; 0.0 is non-neg, but doesn't preserve sign
    (-> Negative-Real Positive-Real Nonpositive-Real) ; idem
    (-> Positive-Real Negative-Real Nonpositive-Real) ; idem
    (-> Negative-Real Negative-Real Negative-Real Nonpositive-Real) ; idem
    (varop-1+ Real)
    ;; complexes
    (varop-1+ Float-Complex)
    (commutative-case Float-Complex (union Inexact-Complex Inexact-Real Positive-Rational Negative-Rational) Float-Complex)
    (->* (list Float-Complex) Number Float-Complex) ; if any argument after the first is exact 0, not a problem
    (varop-1+ Single-Float-Complex)
    (commutative-case Single-Float-Complex (union Single-Float-Complex Single-Float Positive-Rational Negative-Rational) Single-Float-Complex)
    (varop-1+ Inexact-Complex)
    (commutative-case Inexact-Complex (union Inexact-Complex Inexact-Real Positive-Rational Negative-Rational) Inexact-Complex)
    (varop-1+ Number))]

[max
 (from-cases (map varop (list Zero One))
             (commutative-case One Zero)
             (commutative-case Positive-Byte Byte)
             (commutative-case Positive-Index Index)
             (commutative-case Positive-Fixnum Fixnum)
             (commutative-case Nonnegative-Fixnum Fixnum)
             (map varop (list Index Negative-Fixnum Nonpositive-Fixnum Positive-Fixnum Nonnegative-Fixnum Fixnum))
             (commutative-case Positive-Integer Integer)
             (commutative-case Nonnegative-Integer Integer)
             (map varop (list Negative-Integer Nonpositive-Integer Positive-Integer Nonnegative-Integer Integer))
             ;; we could have more cases here. for instance, when mixing PosInt
             ;; and NegRats, we get a result of type PosInt (not just PosRat)
             ;; there's a lot of these, but they may not be worth including
             (commutative-case Positive-Rational Rational)
             (commutative-case Nonnegative-Rational Rational)
             (map varop (list Negative-Rational Nonpositive-Rational Positive-Rational Nonnegative-Rational Rational
                                 Float-Positive-Zero Float-Negative-Zero Float-Zero))
             ;; inexactness is contagious: (max 3 2.3) => 3.0
             ;; we could add cases to encode that
             (commutative-case Positive-Float Float)
             (commutative-case Nonnegative-Float Float)
             (map varop (list Negative-Float Nonpositive-Float Positive-Float Nonnegative-Float Float
                              Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero))
             (varop Positive-Single-Float)
             (commutative-case Positive-Single-Float Single-Float)
             (varop Nonnegative-Single-Float)
             (commutative-case Nonnegative-Single-Float Single-Float)
             (map varop (list Negative-Single-Float Nonpositive-Single-Float Single-Float
                              Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero))
             (commutative-case Positive-Inexact-Real Inexact-Real)
             (commutative-case Nonnegative-Inexact-Real Inexact-Real)
             (map varop (list Negative-Inexact-Real Nonpositive-Inexact-Real Positive-Inexact-Real Nonnegative-Inexact-Real
                              Inexact-Real Real-Zero))
             (commutative-case Positive-Real Real)
             (commutative-case Nonnegative-Real Real)
             (map varop (list Negative-Real Nonpositive-Real Positive-Real Nonnegative-Real Real)))]
[min
 (from-cases (map varop (list Zero One))
             (commutative-case Zero One)
             (map varop (list Positive-Byte Byte Positive-Index Index Positive-Fixnum Nonnegative-Fixnum))
             (commutative-case Negative-Fixnum Fixnum)
             (commutative-case Nonpositive-Fixnum Fixnum)
             (commutative-case Positive-Byte Positive-Integer)
             (commutative-case Byte Nonnegative-Integer)
             (commutative-case Positive-Fixnum Positive-Integer)
             (commutative-case Nonnegative-Fixnum Nonnegative-Integer)
             (map varop (list Negative-Fixnum Nonpositive-Fixnum Fixnum Positive-Integer Nonnegative-Integer))
             (commutative-case Negative-Integer Integer)
             (commutative-case Nonpositive-Integer Integer)
             (map varop (list Negative-Integer Nonpositive-Integer Integer Positive-Rational Nonnegative-Rational))
             (commutative-case Negative-Rational Rational)
             (commutative-case Nonpositive-Rational Rational)
             (map varop (list Negative-Rational Nonpositive-Rational Rational
                              Float-Positive-Zero Float-Negative-Zero Float-Zero
                              Positive-Float Nonnegative-Float))
             (commutative-case Negative-Float Float)
             (commutative-case Nonpositive-Float Float)
             (map varop (list Negative-Float Nonpositive-Float Float
                              Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero
                              Positive-Single-Float Nonnegative-Single-Float))
             (commutative-case Negative-Single-Float Single-Float)
             (commutative-case Nonpositive-Single-Float Single-Float)
             (map varop (list Negative-Single-Float Nonpositive-Single-Float Single-Float
                              Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero
                              Positive-Inexact-Real Nonnegative-Inexact-Real))
             (commutative-case Negative-Inexact-Real Inexact-Real)
             (commutative-case Nonpositive-Inexact-Real Inexact-Real)
             (map varop (list Negative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                              Real-Zero Positive-Real Nonnegative-Real))
             (commutative-case Negative-Real Real)
             (commutative-case Nonpositive-Real Real)
             (map varop (list Negative-Real Nonpositive-Real Real)))]

[add1 (from-cases
       (-> Zero One)
       (-> One Positive-Byte)
       (-> Byte Positive-Index)
       (-> Index Positive-Fixnum)
       (-> Negative-Fixnum Nonpositive-Fixnum)
       (-> Nonpositive-Fixnum Fixnum)
       (-> Nonnegative-Integer -Pos)
       (-> Negative-Integer Nonpositive-Integer)
       (unop Integer)
       (-> Nonnegative-Rational Positive-Rational)
       (unop Rational)
       (-> Nonnegative-Float Positive-Float)
       (unop Float)
       (-> Nonnegative-Single-Float Positive-Single-Float)
       (unop Single-Float)
       (-> Nonnegative-Inexact-Real Positive-Inexact-Real)
       (unop Inexact-Real)
       (-> Nonnegative-Real Positive-Real)
       (map unop (list Real Float-Complex Single-Float-Complex Inexact-Complex Number)))]

[sub1 (from-cases
       (-> One Zero)
       (-> Positive-Byte Byte)
       (-> Positive-Index Index)
       (-> Index Fixnum)
       (-> Positive-Fixnum Nonnegative-Fixnum)
       (-> Nonnegative-Fixnum Fixnum)
       (-> -Pos Nonnegative-Integer)
       (-> Nonpositive-Integer Negative-Integer)
       (unop Integer)
       (-> Nonpositive-Rational Negative-Rational)
       (unop Rational)
       (-> Nonpositive-Float Negative-Float)
       (unop Float)
       (-> Nonpositive-Single-Float Negative-Single-Float)
       (unop Single-Float)
       (-> Nonpositive-Inexact-Real Negative-Inexact-Real)
       (unop Inexact-Real)
       (-> Nonpositive-Real Negative-Real)
       (map unop (list Real Float-Complex Single-Float-Complex Inexact-Complex Number)))]

[quotient
 (from-cases
  (Zero Integer . -> . Zero)
  (map (lambda (t) (-> t One t)) ; division by one is identity
       (list Positive-Byte Byte Positive-Index Index
             Positive-Fixnum Nonnegative-Fixnum Negative-Fixnum Nonpositive-Fixnum Fixnum))
  (Byte Nonnegative-Integer . -> . Byte)
  (Byte Integer . -> . Fixnum) ; may be negative
  (Index Nonnegative-Integer . -> . Index)
  (Index Integer . -> . Fixnum) ; same.
  ;; we don't have equivalent for fixnums:
  ;; (quotient min-fixnum -1) -> max-fixnum + 1
  (commutative-binop Nonnegative-Fixnum Nonpositive-Fixnum Nonpositive-Fixnum)
  (Nonpositive-Fixnum Nonpositive-Fixnum . -> . Nonnegative-Integer)
  (Nonnegative-Fixnum Nonnegative-Integer . -> . Nonnegative-Fixnum)
  (Nonnegative-Fixnum Integer . -> . Fixnum)
  (binop Nonnegative-Integer)
  (commutative-binop Nonnegative-Integer Nonpositive-Integer Nonpositive-Integer)
  (Nonpositive-Integer Nonpositive-Integer . -> . Nonnegative-Integer)
  (binop Integer))]
[remainder ; result has same sign as first arg
 (from-cases
  (One One . -> . Zero)
  (map (lambda (t) (list (-> Nonnegative-Integer t t)
                         (-> t Integer t)))
       (list Byte Index Nonnegative-Fixnum Nonnegative-Integer))
  (Nonpositive-Fixnum Integer . -> . Nonpositive-Fixnum)
  (Nonpositive-Integer Integer . -> . Nonpositive-Integer)
  (commutative-binop Fixnum Integer)
  (binop Integer))]
[modulo ; result has same sign as second arg
 (from-cases
  (One One . -> . Zero)
  (map (lambda (t) (list (-> Integer t t)
                         (-> t Nonnegative-Integer t)))
       (list Byte Index Nonnegative-Fixnum Nonnegative-Integer))
  (Integer Nonpositive-Fixnum . -> . Nonpositive-Fixnum)
  (Integer Nonpositive-Integer . -> . Nonpositive-Integer)
  (commutative-binop Fixnum Integer)
  (binop Integer))]
;; should be consistent with quotient and remainder
[quotient/remainder
 (from-cases
  (Zero Integer . -> . (-values (list Zero Zero)))
  (One One . -> . (-values (list Zero One)))
  ;; division by one is identity, and has no remainder
  (map (lambda (t) (t One . -> . (-values (list t Zero))))
       (list Positive-Byte Byte Positive-Index Index
             Positive-Fixnum Nonnegative-Fixnum Negative-Fixnum Nonpositive-Fixnum Fixnum))
  (Byte Nonnegative-Integer . -> . (-values (list Byte Byte)))
  (Byte Integer . -> . (-values (list Fixnum Byte)))
  (Index Nonnegative-Integer . -> . (-values (list Index Index)))
  (Index Integer . -> . (-values (list Fixnum Index)))
  (Nonnegative-Integer Byte . -> . (-values (list Nonnegative-Integer Byte)))
  (Nonnegative-Integer Index . -> . (-values (list Nonnegative-Integer Index)))
  (Nonnegative-Fixnum Nonnegative-Fixnum . -> . (-values (list Nonnegative-Fixnum Nonnegative-Fixnum)))
  (Nonnegative-Fixnum Nonpositive-Fixnum . -> . (-values (list Nonpositive-Fixnum Nonnegative-Fixnum)))
  (Nonpositive-Fixnum Nonnegative-Fixnum . -> . (-values (list Nonpositive-Fixnum Nonpositive-Fixnum)))
  (Nonpositive-Fixnum Nonpositive-Fixnum . -> . (-values (list Nonnegative-Fixnum Nonpositive-Fixnum)))
  (Nonnegative-Fixnum Nonnegative-Integer . -> . (-values (list Nonnegative-Fixnum Nonnegative-Fixnum)))
  (Nonnegative-Fixnum Integer . -> . (-values (list Fixnum Nonnegative-Fixnum)))
  (Nonnegative-Integer Nonnegative-Fixnum . -> . (-values (list Nonnegative-Integer Nonnegative-Fixnum)))
  ;; in the following cases, we can't guarantee that the quotient is within
  ;; fixnum range: (quotient min-fixnum -1) -> max-fixnum + 1
  (Nonpositive-Fixnum Integer . -> . (-values (list Integer Nonpositive-Fixnum)))
  (Fixnum Integer . -> . (-values (list Integer Fixnum)))
  (Integer Fixnum . -> . (-values (list Integer Fixnum)))
  (Nonnegative-Integer Nonnegative-Integer . -> . (-values (list Nonnegative-Integer Nonnegative-Integer)))
  (Nonnegative-Integer Nonpositive-Integer . -> . (-values (list Nonpositive-Integer Nonnegative-Integer)))
  (Nonnegative-Integer Integer . -> . (-values (list Integer Nonnegative-Integer)))
  (Nonpositive-Integer Nonnegative-Integer . -> . (-values (list Nonpositive-Integer Nonpositive-Integer)))
  (Nonpositive-Integer Nonpositive-Integer . -> . (-values (list Nonnegative-Integer Nonpositive-Integer)))
  (Nonpositive-Integer Integer . -> . (-values (list Integer Nonpositive-Integer)))
  (Integer Integer . -> . (-values (list Integer Integer))))]

[arithmetic-shift (cl->* (Zero Nonpositive-Integer . -> . Zero)
                         (Byte Nonpositive-Integer . -> . Byte)
                         (Index Nonpositive-Integer . -> . Index)
                         (Nonnegative-Fixnum Nonpositive-Integer . -> . Nonnegative-Fixnum)
                         (Fixnum Nonpositive-Integer . -> . Fixnum)
                         (Nonnegative-Integer Integer . -> . Nonnegative-Integer)
                         (Integer Integer . -> . Integer))]

[bitwise-and
 (let ([mix-with-nat
        (lambda (t)
          (list (->* (list t) t t) ; closed
                (->* (list Nonnegative-Integer t) t t) ; brings result down
                (->* (list t Nonnegative-Integer) t t)))])
   (from-cases (-> Negative-Fixnum) ; no args -> -1
               (map mix-with-nat (list Zero Byte Index Nonnegative-Fixnum))
               ;; closed on negatives, but not closed if we mix with positives
               (map varop-1+ (list Negative-Fixnum Nonpositive-Fixnum Fixnum))
               (map mix-with-nat (list Nonnegative-Integer))
               (map varop-1+ (list Negative-Integer Nonpositive-Integer))
               (null Integer . ->* . Integer)))]
[bitwise-ior
 (from-cases (varop Zero)
             (map (lambda (l) (apply commutative-case l))
                  (list (list One Zero)
                        (list Positive-Byte Byte)
                        (list Byte Byte) ; doesn't need commutative case (varop would do), but saves code to put it here
                        (list Positive-Index Index)
                        (list Index Index) ; same
                        (list Positive-Fixnum Nonnegative-Fixnum)
                        (list Nonnegative-Fixnum Nonnegative-Fixnum)
                        (list Negative-Fixnum Fixnum) ; as long as there's one negative, the result is negative
                        (list Fixnum Fixnum)
                        (list Positive-Integer Nonnegative-Integer)
                        (list Nonnegative-Integer Nonnegative-Integer)
                        (list Negative-Integer Integer)
                        (list Integer Integer))))]
[bitwise-not (cl->* (-> Nonnegative-Fixnum Negative-Fixnum)
                    (-> Negative-Fixnum Nonnegative-Fixnum)
                    (-> Fixnum Fixnum)
                    (-> Nonnegative-Integer Negative-Integer)
                    (-> Negative-Integer Nonnegative-Integer)
                    (-> Integer Integer))]
[bitwise-xor
 (from-cases
  (-> One One)
  (-> One One Zero)
  (-> One One One One)
  (map varop-1+ (list Zero Byte Index Nonnegative-Fixnum))
  (-> Negative-Fixnum Negative-Fixnum)
  (-> Nonpositive-Fixnum Nonpositive-Fixnum)
  (-> Negative-Fixnum Negative-Fixnum Nonnegative-Fixnum) ; both have to be negative: (0 -1) -> -1
  (commutative-binop Negative-Fixnum Nonnegative-Fixnum Negative-Fixnum)
  (-> Negative-Fixnum Nonnegative-Fixnum Nonpositive-Fixnum) ; not commutative: (<pos> (ann 0 <non-pos>)) -> <pos>
  (map varop-1+ (list Fixnum Nonnegative-Integer))
  (-> Negative-Integer Negative-Integer)
  (-> Nonpositive-Integer Nonpositive-Integer)
  (-> Negative-Integer Negative-Integer Nonnegative-Integer)
  (commutative-binop Negative-Integer Nonnegative-Integer Negative-Integer)
  (-> Negative-Integer Nonnegative-Integer Nonpositive-Integer) ; see above
  (varop Integer))]
[bitwise-bit-set? (-> Integer Integer B)]
[bitwise-bit-field
 (from-cases (map (lambda (t [r t]) (-> t Integer Integer t))
                  (list Byte Index Nonnegative-Fixnum Nonnegative-Integer))
             ;; you can extract as many bits as you want from any negative number
             (list (-> Integer Integer Integer Integer)))]
[integer-length (-> Integer Nonnegative-Fixnum)]

[abs (from-cases abs-cases)]

;; exactness
[exact->inexact
 (from-cases (map unop all-float-types)
             (Zero . -> . Float-Zero)
             (Positive-Integer . -> . Positive-Float)
             (Negative-Integer . -> . Negative-Float)
             (Positive-Rational . -> . Nonnegative-Float)
             (Negative-Rational . -> . Nonpositive-Float)
             (Rational . -> . Float)
             (map unop (list Float-Zero Positive-Float Nonnegative-Float Negative-Float Nonpositive-Float Float
                             Single-Float-Zero Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float Single-Float))
             (Nonnegative-Real . -> . Nonnegative-Inexact-Real) ; not for Pos, possible underflow
             (Nonpositive-Real . -> . Nonpositive-Inexact-Real)
             (Real . -> . Inexact-Real)
             (Float-Complex . -> . Float-Complex)
             (Single-Float-Complex . -> . Single-Float-Complex)
             (Inexact-Complex . -> . Inexact-Complex)
             (Number . -> . (union Inexact-Real Inexact-Complex)))]
[inexact->exact
 (from-cases (map unop all-rat-types)
             (Real-Zero . -> . Zero)
             (Positive-Real . -> . Positive-Rational)
             (Nonnegative-Real . -> . Nonnegative-Rational)
             (Negative-Real . -> . Negative-Rational)
             (Nonpositive-Real . -> . Nonpositive-Rational)
             (Real . -> . Rational)
             (Number . -> . Exact-Number))]
[fl->exact-integer (cl->*
                    (Float-Zero . -> . Zero)
                    (Positive-Float . -> . Positive-Integer)
                    (Nonnegative-Float . -> . Nonnegative-Integer)
                    (Negative-Float . -> . Negative-Integer)
                    (Nonpositive-Float . -> . Nonpositive-Integer)
                    (Float . -> . Integer))]
[real->single-flonum
 (from-cases (map unop single-flonum-types)
             (Float-Positive-Zero . -> . Single-Float-Positive-Zero)
             (Float-Negative-Zero . -> . Single-Float-Negative-Zero)
             (Real-Zero . -> . Single-Float-Zero)
             (Positive-Integer . -> . Positive-Single-Float)
             (Negative-Integer . -> . Negative-Single-Float)
             ;; no positive / negative cases, possible underflow
             (Nonnegative-Real . -> . Nonnegative-Single-Float)
             (Nonpositive-Real . -> . Nonpositive-Single-Float)
             (Real . -> . Single-Float-Zero))]
[real->double-flonum
 (from-cases (map unop all-flonum-types)
             (Single-Float-Positive-Zero . -> . Float-Positive-Zero)
             (Single-Float-Negative-Zero . -> . Float-Negative-Zero)
             (Real-Zero . -> . Float-Zero)
             (Positive-Integer . -> . Positive-Float)
             (Negative-Integer . -> . Negative-Float)
             ;; no positive / negative cases, possible underflow
             (Nonnegative-Real . -> . Nonnegative-Float)
             (Nonpositive-Real . -> . Nonpositive-Float)
             (Real . -> . Float))]

[floor
 (from-cases
  (map unop all-int-types)
  (-> Nonnegative-Rational Nonnegative-Integer)
  (-> Negative-Rational Negative-Integer)
  (-> Nonpositive-Rational Nonpositive-Integer)
  (-> Rational Integer)
  (map unop (list Float-Positive-Zero Float-Negative-Zero Float-Zero
                  Nonnegative-Float Negative-Float Nonpositive-Float Float
                  Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero
                  Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float Single-Float
                  Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero
                  Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                  Real-Zero Nonnegative-Real Negative-Real Nonpositive-Real Real)))]
[ceiling
 (from-cases
  (map unop all-int-types)
  (-> Positive-Rational Positive-Integer)
  (-> Nonnegative-Rational Nonnegative-Integer)
  (-> Nonpositive-Rational Nonpositive-Integer)
  (-> Rational Integer)
  (map unop (list Float-Positive-Zero Float-Negative-Zero Float-Zero
                  Positive-Float Nonnegative-Float Nonpositive-Float Float
                  Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero
                  Positive-Single-Float Nonnegative-Single-Float Nonpositive-Single-Float Single-Float
                  Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero
                  Positive-Inexact-Real Nonnegative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                  Real-Zero Positive-Real Nonnegative-Real Nonpositive-Real Real)))]
[truncate (round-type)]
[round (round-type)]

[make-rectangular (cl->* (Rational Rational . -> . Exact-Number)
                         (Float Float . -> . Float-Complex)
                         (Float (union Positive-Real Negative-Real) . -> . Float-Complex) ; no exact 0
                         ((union Positive-Real Negative-Real) Float . -> . Float-Complex)
                         (Single-Float Single-Float . -> . Single-Float-Complex)
                         (Inexact-Real Inexact-Real . -> . Inexact-Complex)
                         (Real Real . -> . Number))]
[make-polar (cl->* (Float Float . -> . Float-Complex)
                   (Single-Float Single-Float . -> . Single-Float-Complex)
                   (Inexact-Real Inexact-Real . -> . Inexact-Complex)
                   (Real Real . -> . Number))]
[real-part (from-cases
            (map unop all-real-types)
            (Exact-Number . -> . Rational)
            (Float-Complex . -> . Float)
            (Single-Float-Complex . -> . Single-Float)
            (Inexact-Complex . -> . Inexact-Real)
            (Number . -> . Real))]
[imag-part (cl->* (Real . -> . Zero)
                  (Exact-Number . -> . Rational)
                  (Float-Complex . -> . Float)
                  (Inexact-Complex . -> . Inexact-Real)
                  (Number . -> . Real))]
[magnitude (from-cases abs-cases
                       (Float-Complex . -> . Nonnegative-Float)
                       (Single-Float-Complex . -> . Nonnegative-Single-Float)
                       (Inexact-Complex . -> . Nonnegative-Inexact-Real)
                       (Number . -> . Nonnegative-Real))]
[angle     (cl->* (Positive-Real . -> . Zero)
                  (Float-Complex . -> . Float)
                  (Inexact-Complex . -> . Inexact-Real)
                  (Number . -> . (union Inexact-Real Zero)))]
[numerator
 (from-cases (map unop all-int-types)
             (Positive-Rational . -> . Positive-Integer)
             (Nonnegative-Rational . -> . Nonnegative-Integer)
             (Negative-Rational . -> . Negative-Integer)
             (Nonpositive-Rational . -> . Nonpositive-Integer)
             (Rational . -> . Integer)
             ;; includes rational types, but these have been matched already
             (map unop all-real-types))]
[denominator (cl->* (Integer . -> . One)
                    (Rational . -> . Positive-Integer)
                    (Float . -> . Positive-Float)
                    (Single-Float . -> . Positive-Single-Float)
                    (Inexact-Real . -> . Positive-Inexact-Real)
                    (Real . -> . Positive-Real))]
[rationalize
 (from-cases (map (lambda (t) (-> t Rational t))
                  all-int-types)
             (Nonnegative-Rational Rational . -> . Nonnegative-Rational) ; non-zero args produce zero
             (Nonpositive-Rational Rational . -> . Nonpositive-Rational)
             (Rational Rational . -> . Rational)
             (map (lambda (l) (apply commutative-binop l))
                  ;; actually, second argument could be negative in all cases,
                  ;; and it would still work, but this would require twice as
                  ;; many cases
                  (list (list Nonnegative-Real Nonnegative-Float)
                        (list Nonpositive-Real Nonpositive-Float)
                        (list Real Float)
                        (list Nonnegative-Real Nonnegative-Single-Float)
                        (list Nonpositive-Real Nonpositive-Single-Float)
                        (list Real Single-Float)
                        (list Nonnegative-Real Nonnegative-Inexact-Real)
                        (list Nonpositive-Real Nonpositive-Inexact-Real)
                        (list Real Inexact-Real)))
             (map binop (list Nonnegative-Real Nonpositive-Real Real)))]
[expt
 (from-cases (-> One Rational One)
             (map (lambda (t) (-> t Zero One)) all-number-types) ; will error if negative
             (Positive-Integer Nonnegative-Integer . -> . Positive-Integer)
             (Nonnegative-Integer Nonnegative-Integer . -> . Nonnegative-Integer)
             (Integer Nonnegative-Integer . -> . Integer)
             (Positive-Integer Integer . -> . Positive-Rational)
             (Nonnegative-Integer Integer . -> . Nonnegative-Rational)
             (Integer Integer . -> . Rational)
             (Positive-Rational Integer . -> . Positive-Rational)
             (Nonnegative-Rational Integer . -> . Nonnegative-Rational)
             (Rational Integer . -> . Rational)
             (Nonnegative-Float Float . -> . Nonnegative-Float)
             (Nonnegative-Float Real . -> . (union Nonnegative-Float One))
             (Positive-Real Nonnegative-Float . -> . (union Nonnegative-Float One))
             ;; even integer exponents can give complex results
             ;; too large exponents turn into infinities, and (expt -inf.0 -inf.0) => nan.0+nan.0i
             ;; so no narrower cases for those. fixnums are ok, though
             (Float (union Negative-Fixnum Positive-Fixnum) . -> . Float)
             (Float Fixnum . -> . (union Float One))
             (Float Float . -> . (union Float Float-Complex))
             ;; 1st arg can't be non-neg, -0.0 gives the wrong sign
             (Positive-Single-Float (union Single-Float Negative-Fixnum Positive-Fixnum) . -> . Nonnegative-Single-Float)
             (Nonnegative-Single-Float (union Single-Float Negative-Fixnum Positive-Fixnum) . -> . Single-Float)
             (Single-Float (union Negative-Fixnum Positive-Fixnum) . -> . Single-Float)
             (Single-Float Fixnum . -> . (union Single-Float One))
             (Single-Float Single-Float . -> . (union Single-Float Single-Float-Complex))
             (Positive-Inexact-Real (union Negative-Fixnum Positive-Fixnum) . -> . Nonnegative-Inexact-Real)
             (Nonnegative-Inexact-Real (union Negative-Fixnum Positive-Fixnum) . -> . Inexact-Real)
             (Positive-Real Real . -> . Nonnegative-Real)
             (Nonnegative-Real Real . -> . Real)
             (Inexact-Real (union Negative-Fixnum Positive-Fixnum) . -> . Inexact-Real)
             (Inexact-Real Inexact-Real . -> . (union Inexact-Real Inexact-Complex))
             (Real Nonnegative-Integer . -> . Real)
             (Float-Complex Float-Complex . -> . Float-Complex)
             (Float-Complex Float . -> . (union Float-Complex Float))
             (Float-Complex Inexact-Real . -> . (union Float-Complex Inexact-Real))
             (Float-Complex Inexact-Complex . -> . Float-Complex)
             (Single-Float-Complex Single-Float-Complex . -> . Single-Float-Complex)
             (Single-Float-Complex Single-Float . -> . (union Single-Float-Complex Single-Float))
             (Inexact-Complex Inexact-Complex . -> . Inexact-Complex)
             (Number Number . -> . Number))]
[sqrt
 (from-cases
  (map unop (list Zero One
                  Float-Positive-Zero Float-Negative-Zero Float-Zero Positive-Float Nonnegative-Float
                  Single-Float-Positive-Zero Single-Float-Negative-Zero Single-Float-Zero Positive-Single-Float Nonnegative-Single-Float
                  Inexact-Real-Positive-Zero Inexact-Real-Negative-Zero Inexact-Real-Zero Positive-Inexact-Real Nonnegative-Inexact-Real
                  Real-Zero Positive-Real Nonnegative-Real))
  (Float-Complex . -> . Float-Complex)
  (Single-Float-Complex . -> . Single-Float-Complex)
  (Inexact-Complex . -> . Inexact-Complex)
  (Number . -> . Number))]
[integer-sqrt
 (from-cases
  (-> (union Real-Zero One) (union Real-Zero One) : -true-propset : (-arg-path 0))
  (unop Byte)
  (Nonnegative-Fixnum . -> . Index)
  (Nonnegative-Rational . -> . Nonnegative-Integer)
  (map unop (list Nonnegative-Float Nonnegative-Single-Float Nonnegative-Inexact-Real Nonnegative-Real))
  ; This errors on NaN so we can ignore it
  (Rational . -> . Exact-Number)
  (Real . -> . Number))] ; defined on inexact integers too, but not complex
[integer-sqrt/remainder
 (from-cases
  (Real-Zero . -> . (make-Values (list (-result Real-Zero -true-propset (-arg-path 0))
                                       (-result Real-Zero -true-propset (-arg-path 0)))))
  (One . -> . (-values (list One Zero)))
  (Byte . -> . (-values (list Byte Byte)))
  (Index . -> . (-values (list Index Index)))
  (Nonnegative-Fixnum . -> . (-values (list Index Nonnegative-Fixnum)))
  (Nonnegative-Rational . -> . (-values (list Nonnegative-Integer Nonnegative-Integer)))

  (map (λ (t) (t . -> . (-values (list t t))))
       (list Nonnegative-Float
             Nonnegative-Single-Float
             Nonnegative-Inexact-Real
             Nonnegative-Real))

  (Rational . -> . (-values (list Exact-Number Integer)))
  (Real . -> . (-values (list Number Real))))] ; defined on inexact integers too

[log (cl->*
      (Nonnegative-Rational . -> . Real)
      (Float-Zero . -> . Negative-Float)
      (Nonnegative-Float . -> . Float)
      (Single-Float-Zero . -> . Negative-Single-Float)
      (Nonnegative-Single-Float . -> . Single-Float)
      (Inexact-Real-Zero . -> . Negative-Inexact-Real)
      (Nonnegative-Inexact-Real . -> . Inexact-Real)
      (Nonnegative-Real . -> . Real)
      (Float-Complex . -> . Float-Complex)
      (Single-Float-Complex . -> . Single-Float-Complex)
      (Inexact-Complex . -> . Inexact-Complex)
      (Number . -> . Number))]
[exp (from-cases (Zero . -> . One)
                 (map unop
                      (list Float Single-Float Inexact-Real Real
                            Float-Complex Single-Float-Complex Inexact-Complex Number)))]

[cos (from-cases (Zero . -> . One)
                 (map unop
                      (list Float Single-Float Inexact-Real Real
                            Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[sin (from-cases (map unop
                      (list Zero Float Single-Float Inexact-Real Real
                            Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[tan (from-cases (map unop
                      (list Zero Float Single-Float Inexact-Real Real
                            Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[acos (from-cases (One . -> . Zero)
                  (map unop
                       (list Float Single-Float Inexact-Real Real
                             Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[asin (from-cases (Zero . -> . One)
                  (map unop
                       (list Float Single-Float Inexact-Real Real
                             Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[atan (from-cases
       (map unop (list Zero Float Single-Float Inexact-Real Real
                       Float-Complex Single-Float-Complex Inexact-Complex Number))
       ;; 2-arg case, atan2
       (Zero Positive-Rational . -> . Zero)
       (map binop (list Float Single-Float Inexact-Real Real)))]

[gcd (from-cases (varop Zero)
                 (varop-1+ One)
                 (varop-1+ Positive-Byte)
                 (varop Byte)
                 (varop-1+ Positive-Index)
                 (varop Index)
                 (varop-1+ Positive-Fixnum)
                 (varop Fixnum Nonnegative-Fixnum)
                 (varop-1+ Positive-Integer)
                 (varop Integer Nonnegative-Integer)
                 (varop-1+ Positive-Rational)
                 (varop Rational Nonnegative-Rational)
                 ;; also supports inexact integers
                 (varop-1+ Positive-Float)
                 (commutative-case Positive-Float Positive-Real Positive-Float)
                 (varop Float Nonnegative-Float)
                 (commutative-case Float Real Nonnegative-Float)
                 (varop-1+ Positive-Single-Float)
                 (varop Single-Float Nonnegative-Single-Float)
                 (varop-1+ Positive-Inexact-Real)
                 (varop Inexact-Real Nonnegative-Inexact-Real)
                 ;; Note: this will mess up error messages, since only integers
                 ;; (exact or not) are accepted, not any reals.
                 ;; should we only accept exact integers?
                 (varop-1+ Positive-Real)
                 (varop Real Nonnegative-Real))]
[lcm (from-cases (map unop (list Zero One Positive-Byte Byte Positive-Index Index Positive-Fixnum))
                 (Negative-Fixnum . -> . Positive-Fixnum)
                 (Fixnum . -> . Nonnegative-Fixnum)
                 (commutative-case Zero Rational) ; zero anywhere -> zero
                 (commutative-case Real-Zero Real)
                 (map (lambda (t) (commutative-binop One t))
                      (list Positive-Byte Byte Positive-Index Index Positive-Fixnum))
                 (commutative-binop One Negative-Fixnum Positive-Fixnum)
                 (commutative-binop One Fixnum Nonnegative-Fixnum)
                 (binop Positive-Byte Positive-Index)
                 (binop Byte Index)
                 (varop (union Positive-Integer Negative-Integer) Positive-Integer)
                 (varop Integer Nonnegative-Integer)
                 (varop (union Positive-Rational Negative-Rational) Positive-Rational)
                 (varop Rational Nonnegative-Rational)
                 ;; also supports inexact integers
                 (commutative-case Float-Zero Real Float-Zero)
                 (commutative-case Single-Float-Zero Real Single-Float-Zero)
                 (commutative-case Inexact-Real-Zero Real Inexact-Real-Zero)
                 (varop-1+ (union Positive-Float Negative-Float) Positive-Float)
                 (varop-1+ Float Nonnegative-Float)
                 (commutative-case (union Positive-Float Negative-Float) (union Positive-Real Negative-Real) Positive-Float)
                 (commutative-case Float (union Positive-Real Negative-Real) Nonnegative-Float) ; exact 0 -> exact 0
                 (varop-1+ (union Positive-Single-Float Negative-Single-Float) Positive-Single-Float)
                 (varop-1+ Single-Float Nonnegative-Single-Float)
                 (varop-1+ (union Positive-Inexact-Real Negative-Inexact-Real) Positive-Inexact-Real)
                 (varop-1+ Inexact-Real Nonnegative-Inexact-Real)
                 ;; Note: same as above.
                 (varop (union Positive-Real Negative-Real) Positive-Real)
                 (varop Real Nonnegative-Real))]

;; racket/math

[sgn (cl->* (Zero . -> . Zero)
            (Positive-Rational . -> . One)
            (Nonnegative-Rational . -> . (union Zero One))
            (Negative-Rational . -> . (-val -1))
            (Nonpositive-Rational . -> .(union (-val -1) Zero))
            (Rational . -> . (union (-val -1) Zero One))
            (Float . -> . Float)
            (Single-Float . -> . Single-Float)
            (Real . -> . Real))]

[pi Positive-Float]
[pi.f Positive-Single-Float]
[sqr (from-cases (map unop (list Zero One))
                 (-> Positive-Byte Positive-Index)
                 (-> Byte Index)
                 (unop Positive-Integer)
                 (-> Integer Nonnegative-Integer)
                 (unop Positive-Rational)
                 (-> Rational Nonnegative-Rational)
                 ;; possible underflow, no pos -> pos
                 (-> Float Nonnegative-Float)
                 (-> Single-Float Nonnegative-Single-Float)
                 (-> Inexact-Real Nonnegative-Inexact-Real)
                 (-> Real Nonnegative-Real)
                 (map unop (list Float-Complex Single-Float-Complex
                                 Inexact-Complex Exact-Number Number)))]
[conjugate (from-cases
            (map unop all-real-types)
            (Float-Complex . -> . Float-Complex)
            (Single-Float-Complex . -> . Single-Float-Complex)
            (Inexact-Complex . -> . Inexact-Complex)
            (Exact-Number . -> . Exact-Number)
            (Number . -> . Number))]
[sinh (from-cases
       (unop Zero) ; only exact case
       ;; possible underflow, no pos -> pos. 0 -> 0, no Nonnegative-Rational -> Nonnegative-Float
       ((union Positive-Rational Nonnegative-Float) . -> . Nonnegative-Float)
       ((union Negative-Rational Nonpositive-Float) . -> . Nonpositive-Float)
       (map unop (list Float-NaN Float
                       Single-Flonum-NaN Nonnegative-Single-Float Nonpositive-Single-Float Single-Float
                       Nonnegative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                       Nonnegative-Real Nonpositive-Real Real
                       Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[cosh (from-cases ; no exact cases
       (map unop (list Float-NaN Single-Flonum-NaN))
       ((union Rational Float) . -> . Positive-Float)
       (Single-Float . -> . Positive-Single-Float)
       (Inexact-Real . -> . Positive-Inexact-Real)
       (Real . -> . Positive-Real)
       (map unop (list Float-Complex Single-Float-Complex Inexact-Complex Number)))]
[tanh (from-cases ; same as sinh
       (unop Zero) ; only exact case
       ;; possible underflow, no pos -> pos. 0 -> 0, no Nonnegative-Rational -> Nonnegative-Float
       ((union Positive-Rational Nonnegative-Float) . -> . Nonnegative-Float)
       ((union Negative-Rational Nonpositive-Float) . -> . Nonpositive-Float)
       (map unop (list Float-NaN Float
                       Single-Flonum-NaN Nonnegative-Single-Float Nonpositive-Single-Float Single-Float
                       Nonnegative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                       Nonnegative-Real Nonpositive-Real Real
                       Float-Complex Single-Float-Complex Inexact-Complex Number)))]

[degrees->radians
 (from-cases
  (unop Zero) ; only exact case
  ((union Positive-Rational Positive-Float) . -> . Nonnegative-Float) ; possible underflow, no pos -> pos
  ((union Negative-Rational Negative-Float) . -> . Nonpositive-Float)
  ((union Positive-Single-Float) . -> . Nonnegative-Single-Float)
  ((union Negative-Single-Float) . -> . Nonpositive-Single-Float)
  (map unop (list Float-NaN Single-Flonum-NaN
                  Nonnegative-Float Nonpositive-Float Float
                  Nonnegative-Single-Float Nonpositive-Single-Float Single-Float
                  Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                  Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real Real)))]

[radians->degrees
 (from-cases
  (unop Zero) ; only exact case
  ((union Positive-Rational Positive-Float) . -> . Positive-Float)
  ((union Negative-Rational Negative-Float) . -> . Negative-Float)
  (map unop (list Float-NaN Single-Flonum-NaN
                  Nonnegative-Float Nonpositive-Float Float
                  Positive-Single-Float Nonnegative-Single-Float Negative-Single-Float Nonpositive-Single-Float Single-Float
                  Positive-Inexact-Real Nonnegative-Inexact-Real Negative-Inexact-Real Nonpositive-Inexact-Real Inexact-Real
                  Positive-Real Nonnegative-Real Negative-Real Nonpositive-Real Real)))]

[exact-round (exact-round-type)]
[exact-truncate (exact-round-type)]

[exact-floor
 (from-cases
  (map unop all-int-types)
  (inexact-zero->exact-zero-type)
  (-> (union Nonnegative-Rational Nonnegative-Float Nonnegative-Single-Float Nonnegative-Inexact-Real Nonnegative-Real) Nonnegative-Integer)
  (-> (union Negative-Rational Negative-Float Negative-Single-Float Negative-Inexact-Real Negative-Real) Negative-Integer)
  (-> (union Nonpositive-Rational Nonpositive-Float Nonpositive-Single-Float Nonpositive-Inexact-Real Nonpositive-Real) Nonpositive-Integer)
  (-> (union Rational Float Single-Float Inexact-Real Real) Integer))]

[exact-ceiling
 (from-cases
  (map unop all-int-types)
  (inexact-zero->exact-zero-type)
  (-> (union Positive-Rational Positive-Float Positive-Single-Float Positive-Inexact-Real Positive-Real) Positive-Integer)
  (-> (union Nonnegative-Rational Nonnegative-Float Nonnegative-Single-Float Nonnegative-Inexact-Real Nonnegative-Real) Nonnegative-Integer)
  (-> (union Nonpositive-Rational Nonpositive-Float Nonpositive-Single-Float Nonpositive-Inexact-Real Nonpositive-Real) Nonpositive-Integer)
  (-> (union Rational Float Single-Float Inexact-Real Real) Integer))]

[nan? (make-pred-ty (list Real) Boolean Inexact-Real-NaN)]

[infinite? (make-pred-ty (list Real) Boolean (union -PosInfinity -NegInfinity))]
[positive-integer? (asym-pred Any Boolean (-PS (-is-type 0 (union Positive-Integer Positive-Float Positive-Single-Float))
                                          (-not-type 0 Positive-Integer)))]
[negative-integer? (asym-pred Any Boolean (-PS (-is-type 0 (union Negative-Integer Negative-Float Negative-Single-Float))
                                          (-not-type 0 Negative-Integer)))]
[nonpositive-integer? (asym-pred Any Boolean (-PS (-is-type 0 (union Nonpositive-Integer Nonpositive-Float Nonpositive-Single-Float))
                                             (-not-type 0 Nonpositive-Integer)))]
[nonnegative-integer? (asym-pred Any Boolean (-PS (-is-type 0 (union Nonnegative-Integer Nonnegative-Float Nonnegative-Single-Float))
                                             (-not-type 0 Nonnegative-Integer)))]
[natural? (make-pred-ty Nonnegative-Integer)]

;; racket/fixnum
[fx+ (fx+-type)]
[fx- (fx--type)]
[fx* (fx*-type)]
[fxquotient (fxquotient-type)]
[fxremainder (fxremainder-type)]
[fxmodulo (fxmodulo-type)]
[fxabs (fxabs-type)]

[fxand (fxand-type)]
[fxior (fxior-type)]
[fxxor (fxxor-type)]
[fxnot (fxnot-type)]
[fxlshift (fxlshift-type)]
[fxrshift (fxrshift-type)]

[fx= (fx=-type)]
[fx< (fx<-type)]
[fx> (fx>-type)]
[fx<= (fx<=-type)]
[fx>= (fx>=-type)]
[fxmin (fxmin-type)]
[fxmax (fxmax-type)]

[unsafe-fx+ (fx+-type)]
[unsafe-fx- (fx--type)]
[unsafe-fx* (fx*-type)]
[unsafe-fxquotient (fxquotient-type)]
[unsafe-fxremainder (fxremainder-type)]
[unsafe-fxmodulo (fxmodulo-type)]
[unsafe-fxabs (fxabs-type)]

[unsafe-fxand (fxand-type)]
[unsafe-fxior (fxior-type)]
[unsafe-fxxor (fxxor-type)]
[unsafe-fxnot (fxnot-type)]
[unsafe-fxlshift (fxlshift-type)]
[unsafe-fxrshift (fxrshift-type)]

[unsafe-fx= (fx=-type)]
[unsafe-fx< (fx<-type)]
[unsafe-fx> (fx>-type)]
[unsafe-fx<= (fx<=-type)]
[unsafe-fx>= (fx>=-type)]
[unsafe-fxmin (fxmin-type)]
[unsafe-fxmax (fxmax-type)]


;; flonum ops
[flabs (flabs-type 'flonum)]
[fl+ (fl+-type 'flonum)]
[fl- (fl--type 'flonum)]
[fl* (fl*-type 'flonum)]
[fl/ (fl/-type 'flonum)]
[fl= (fl=-type 'flonum)]
[fl<= (fl<=-type 'flonum)]
[fl>= (fl>=-type 'flonum)]
[fl> (fl>-type 'flonum)]
[fl< (fl<-type 'flonum)]
[flmin (flmin-type 'flonum)]
[flmax (flmax-type 'flonum)]
[flround (flround-type 'flonum)]
[flfloor (flfloor-type 'flonum)]
[flceiling (flceiling-type 'flonum)]
[fltruncate (flround-type 'flonum)]
[flsin (fl-unop)] ; special cases (0s) not worth special-casing
[flcos (fl-unop)]
[fltan (fl-unop)]
[flatan (fl-unop)]
[flasin (fl-unop)]
[flacos (fl-unop)]
[fllog (fllog-type 'flonum)]
[flexp (flexp-type 'flonum)]
[flsqrt (flsqrt-type 'flonum)]
[flexpt (flexpt-type 'flonum)]
[->fl (fx->fl-type 'flonum)]
[fx->fl (fx->fl-type 'flonum)]
[fl->fx (fl->fx-type 'flonum)]
[make-flrectangular (make-flrectangular-type)]
[flreal-part (flreal-part-type)]
[flimag-part (flimag-part-type)]
[flrandom (flrandom-type)]

[unsafe-flabs (flabs-type 'flonum)]
[unsafe-fl+ (fl+-type 'flonum)]
[unsafe-fl- (fl--type 'flonum)]
[unsafe-fl* (fl*-type 'flonum)]
[unsafe-fl/ (fl/-type 'flonum)]
[unsafe-fl= (fl=-type 'flonum)]
[unsafe-fl<= (fl<=-type 'flonum)]
[unsafe-fl>= (fl>=-type 'flonum)]
[unsafe-fl> (fl>-type 'flonum)]
[unsafe-fl< (fl<-type 'flonum)]
[unsafe-flmin (flmin-type 'flonum)]
[unsafe-flmax (flmax-type 'flonum)]

;These are currently the same binding as the safe versions
;and so are not needed. If this changes they should be
;uncommented. There is a check in the definitions part of
;the file that makes sure that they are the same binding.
;
;[unsafe-flround (flround-type 'flonum)]
;[unsafe-flfloor (flfloor-type 'flonum)]
;[unsafe-flceiling (flceiling-type 'flonum)]
;[unsafe-fltruncate (flround-type 'flonum)]
;[unsafe-flsin (fl-unop)]
;[unsafe-flcos (fl-unop)]
;[unsafe-fltan (fl-unop)]
;[unsafe-flatan (fl-unop)]
;[unsafe-flasin (fl-unop)]
;[unsafe-flacos (fl-unop)]
;[unsafe-fllog (fllog-type 'flonum)]
;[unsafe-flexp (flexp-type 'flonum)]
;[unsafe-flexpt (flexpt-type 'flonum)]
;
[unsafe-flsqrt (flsqrt-type 'flonum)]
[unsafe-fx->fl (fx->fl-type 'flonum)]
[unsafe-fl->fx (fl->fx-type 'flonum)]
[unsafe-make-flrectangular (make-flrectangular-type)]
[unsafe-flreal-part (flreal-part-type)]
[unsafe-flimag-part (flimag-part-type)]
[unsafe-flrandom (flrandom-type)]

; racket/extflonum
[extflonum? (make-pred-ty -ExtFlonum)]
[extflonum-available? (-> B)]
[pi.t -PosExtFlonum]

[extflabs (flabs-type 'ext-flonum)]
[extfl+ (fl+-type 'ext-flonum)]
[extfl- (fl--type 'ext-flonum)]
[extfl* (fl*-type 'ext-flonum)]
[extfl/ (fl/-type 'ext-flonum)]
[extfl= (fl=-type 'ext-flonum)]
[extfl<= (fl<=-type 'ext-flonum)]
[extfl>= (fl>=-type 'ext-flonum)]
[extfl> (fl>-type 'ext-flonum)]
[extfl< (fl<-type 'ext-flonum)]
[extflmin (flmin-type 'ext-flonum)]
[extflmax (flmax-type 'ext-flonum)]
[extflround (flround-type 'ext-flonum)]
[extflfloor (flfloor-type 'ext-flonum)]
[extflceiling (flceiling-type 'ext-flonum)]
[extfltruncate (flround-type 'ext-flonum)]
[extflsin (extfl-unop)] ; special cases (0s) not worth special-casing
[extflcos (extfl-unop)]
[extfltan (extfl-unop)]
[extflatan (extfl-unop)]
[extflasin (extfl-unop)]
[extflacos (extfl-unop)]
[extfllog (fllog-type 'ext-flonum)]
[extflexp (flexp-type 'ext-flonum)]
[extflexpt (flexpt-type 'ext-flonum)]
[extflsqrt (flsqrt-type 'ext-flonum)]
[->extfl (fx->fl-type 'ext-flonum)]
[extfl->exact-integer (cl->* (-ExtFlonumZero . -> . Zero)
                             (-PosExtFlonum . -> . Positive-Integer)
                             (-NonNegExtFlonum . -> . Nonnegative-Integer)
                             (-NegExtFlonum . -> . Negative-Integer)
                             (-NonPosExtFlonum . -> . Nonpositive-Integer)
                             (-ExtFlonum . -> . Integer))]
[real->extfl (cl->* (Real-Zero . -> . -ExtFlonumZero)
                    ;; no positive / negative cases, possible underflow
                    (Nonnegative-Real . -> . -NonNegExtFlonum)
                    (Nonpositive-Real . -> . -NonPosExtFlonum)
                    (Real . -> . -ExtFlonum))]
[extfl->exact (cl->* (-ExtFlonumZero . -> . Zero)
                     (-PosExtFlonum . -> . Positive-Rational)
                     (-NonNegExtFlonum . -> . Nonnegative-Rational)
                     (-NegExtFlonum . -> . Negative-Rational)
                     (-NonPosExtFlonum . -> . Nonpositive-Rational)
                     (-ExtFlonum . -> . Rational))]
[extfl->inexact (cl->* (-ExtFlonumZero . -> . Float-Zero)
                       ;; no positive / negative cases, possible underflow
                       (-NonNegExtFlonum . -> . Nonnegative-Float)
                       (-NonPosExtFlonum . -> . Nonpositive-Float)
                       (-ExtFlonum . -> . Float))]
[unsafe-extflabs (flabs-type 'ext-flonum)]
[unsafe-extfl+ (fl+-type 'ext-flonum)]
[unsafe-extfl- (fl--type 'ext-flonum)]
[unsafe-extfl* (fl*-type 'ext-flonum)]
[unsafe-extfl/ (fl/-type 'ext-flonum)]
[unsafe-extfl= (fl=-type 'ext-flonum)]
[unsafe-extfl<= (fl<=-type 'ext-flonum)]
[unsafe-extfl>= (fl>=-type 'ext-flonum)]
[unsafe-extfl> (fl>-type 'ext-flonum)]
[unsafe-extfl< (fl<-type 'ext-flonum)]
[unsafe-extflmin (flmin-type 'ext-flonum)]
[unsafe-extflmax (flmax-type 'ext-flonum)]

;These are currently the same binding as the safe versions
;and so are not needed. If this changes they should be
;uncommented. There is a check in the definitions part of
;the file that makes sure that they are the same binding.
;
;[unsafe-extflround (flround-type 'ext-flonum)]
;[unsafe-extflfloor (flfloor-type 'ext-flonum)]
;[unsafe-extflceiling (flceiling-type 'ext-flonum)]
;[unsafe-extfltruncate (flround-type 'ext-flonum)]
;[unsafe-extflsin (extfl-unop)]
;[unsafe-extflcos (extfl-unop)]
;[unsafe-extfltan (extfl-unop)]
;[unsafe-extflatan (extfl-unop)]
;[unsafe-extflasin (extfl-unop)]
;[unsafe-extflacos (extfl-unop)]
;[unsafe-extfllog (fllog-type 'ext-flonum)]
;[unsafe-extflexp (flexp-type 'ext-flonum)]
;[unsafe-extflexpt (flexpt-type 'ext-flonum)]
;
[unsafe-extflsqrt (flsqrt-type 'ext-flonum)]
[unsafe-fx->extfl (fx->fl-type 'ext-flonum)]
[unsafe-extfl->fx (fl->fx-type 'ext-flonum)]
